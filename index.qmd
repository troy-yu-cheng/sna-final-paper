---
title: "Social Network Analysis"
subtitle: "Structural Dynamics of Retweeter Amplification Backbone Networks: Analysis of COVID-19 Origin Misinformation on Twitter"
author: 
  - name: "Troy (Yu) Cheng"
    email: yc1317@georgetown.edu
    affiliation: Georgetown University
    corresponding: true
df-print: kable
title-block-banner: "#0a0e1a"
title-block-banner-color: "#4DB8FF"
execute:
  warning: false
date: 2025-04-28
date-modified: last-modified
format:
  html:
    embed-resources: true
    toc: true                 
    toc-title: "Contents"     
    toc-location: right       
    number-sections: true
    number-depth: 3       
    smooth-scroll: true       
    css: trycstyle.css 
    code-overflow: wrap
include-in-header:
  text: |
    <link rel="shortcut icon" href="assets/gu.ico" type="image/x-icon">           
highlight-style: nord       
engine: knitr
---

```{r}
#| include: false
library(tidyverse)
library(readr)
library(statnet)
library(intergraph)
library(reshape2)
library(btergm)
library(effectsize)
```

# Abstract

The amplification of misinformation on social media remains a pressing concern, particularly when false narratives gain widespread visibility through the collective behaviors of retweeters themselves. This study reconceptualized retweeters not as passive intermediaries but amplification hubs within **Retweeter Amplification Backbone Networks**, and investigates how distinct co-retweeting behaviors produce structurally differentiated networks. Drawing on a cross-disciplinary framework of computer network architectures, this research examines: (1) **direct co-retweet networks** where both retweeters retweeted the same misinformation tweet, analogous to broadcast-syle amplification with high connectivity but limited subgroup cohesion; (2) **quote pathway co-retweet networks** where both retweeters retweeted misinformation tweet or content quoting it, resembling selective forwarding behaviors that foster localized interpretive communities; and (3) **reply pathway co-retweet networks** where both retweeters retweeted misinformation tweet or content replying to it, mirroring hierarchical routing structures where influential nodes bridge fragmented communities through emotionally charged and interactive discussions. Building on these distinctions, this study addresses the research question: ***How do different retweeter co-dissemination behaviors construct distinct amplification backbone network structures, and how do these structures vary temporally across multiple misinformation events related to the same narrative?*** Using Social Network Analysis (SNA), this study systematically compares structural characteristics—including network density, average degree, degree centralization, and clustering coefficient—across 18 retweeter amplification backbone networks, constructed from six misinformation events related to the same overarching topic on the COVID-19 Wuhan lab origin theory, and ordered chronologically to capture temporal variation in amplification dynamics.

\[pending\]our findings is:

*Keywords: Retweeter amplification backbone networks, collective misinformation amplification, social network analysis, Twitter, COVID-19 Wuhan lab origin theory*

------------------------------------------------------------------------

# Introduction

The rapid spread of misinformation on social media platforms presents serious challenges to public discourse and crisis management. In highly algorithmic environments, information flows are shaped by platform design and patterns of user engagement, which often give false narratives disproportionate visibility and influence (Vosoughi, Roy, & Aral, 2018). Prior research has primarily focused on user-level analyses of misinformation diffusion networks, often conceptualizing retweeters as mere transmission nodes within broader diffusion chains (Guarino et al., 2020; Pierri et al., 2020; Shao et al., 2018). However, this perspective rarely considers how retweeters, as a collective, construct structural backbones that sustain and amplify misinformation narratives through coordinated or patterned co-amplification behaviors. This study introduces the concept of Retweeter Amplification Backbone Networks to foreground retweeters not merely as passive intermediaries but as structurally significant agents whose collective behaviors shape the persistence and amplification potential of misinformation. By systematically examining how distinct co-dissemination behaviors construct the topologies of these backbone networks, this research addresses a critical blind spot in existing misinformation studies.

To understand these structural patterns, this study applies a cross-disciplinary framework informed by concepts from computer network engineering. It analyzes how different forms of retweeter engagement shape the structural features of amplification networks, including direct co-retweeting, co-retweeting on quote pathway and co-retweeting on reply pathway. Each behavior is defined as a distinct mode of information transmission. Direct retweeting functions like signal broadcasting in Ethernet hubs, quoting resembles selective information forwarding in network switches, and replying operates similarly to routing protocols that manage complex communication pathways (Kurose & Ross, 2021; Barabási, 2016; Forouzan, 2013; Tanenbaum, 2011). This interdisciplinary perspective provides a conceptual framework to understand the organizational logic of retweeter amplification backbones and guides the development of theoretically grounded falsifiable hypotheses regarding the distinct structural outcomes associated with different co-retweeting behaviors.

Using Social Network Analysis, this study examines network density, average degree, centralization, and clustering to compare the structural characteristics of retweeter amplification backbones formed through each engagement behavior. Statistical tests, including t-tests and Conditional Uniform Graph (CUG) models, are used to assess whether observed network patterns differ significantly across these behaviors. Exploratory network modeling is also used to examine structural tendencies within these networks. The empirical focus of this study is a series of six misinformation claims related to the [COVID-19 Wuhan lab origin theory](https://en.wikipedia.org/wiki/COVID-19_lab_leak_theory), spanning from March 2020 to August 2021. This sequence enables an opportunity to explore not only structural differences across co-dissemination behaviors but also temporal variations in retweeter amplification backbones within a unified misinformation narrative. In total, eighteen retweeter amplification backbone networks are analyzed—three amplification pathways across six misinformation events—providing critical insights into how collective retweeter behaviors evolve in response to emerging misinformation waves.

# Literature Review

## Misinformation Amplification on Social Media

The amplification of misinformation on social media has emerged as a critical concern in contemporary communication environments, particularly during crisis events such as the COVID-19 pandemic. Unlike traditional media ecosystems, where information flows are subject to editorial control and verification processes, social media platforms enable the rapid and often unchecked spread of false information. This phenomenon is primarily driven by the psychological appeal of misinformation, which frequently exhibits high levels of novelty and emotional resonance (Vosoughi, Roy, & Aral, 2018). Such content which can stimuli users' intuitive or emotional thinking is more likely to capture user attention and prompt sharing behaviors (Pennycook et al., 2021), thereby accelerating its diffusion .

At the platform level, algorithmic curation further intensifies this process by privileging content that maximizes user engagement (Fernández et al., 2021). Algorithms systematically prioritize emotionally charged content—especially narratives evoking fear, outrage, or moral indignation—because such content generates more interactions and keeps users engaged (Brady et al., 2017; Cinelli et al., 2021). As a consequence, users are frequently exposed to information that reinforces their existing beliefs, creating self-reinforcing informational environments commonly referred to as “echo chambers” (Del Vicario et al., 2016; Guess, Nagler, & Tucker, 2019). In such environments, misinformation becomes more resistant to correction, and its visibility is artificially sustained by both user behavior and algorithmic design.

The COVID-19 pandemic exemplified the societal risks associated with this dynamic. Empirical analyses revealed that misinformation regarding COVID-19 health measures and virus origins often spread more rapidly and reached wider audiences than verified scientific information, complicating public health responses and crisis communication strategies (Cinelli et al., 2020). In response, the World Health Organization introduced the concept of an “infodemic” to describe the overabundance of information—both accurate and misleading—that impedes informed decision-making during public health emergencies (WHO, 2020).

While considerable research has explored the psychological drivers of misinformation spread and the algorithmic mechanisms that reinforce it, less attention has been devoted to understanding the structural foundations that sustain its amplification at the collective level. Despite increasing scholarly interest, the underlying structural mechanisms through which misinformation narratives persist and gain visibility remain insufficiently understood. This gap necessitates a closer examination of how user behaviors aggregate into network structures that contribute to the endurance and reach of misinformation narratives across time.

## Retweeters as Structural Amplifiers






While the amplification of misinformation on social media has been extensively studied, much of the existing literature primarily focuses on two areas: the dynamics of information diffusion through cascade models and the influential role of key individuals in spreading content.

Cascade models (like epidemiological model SIR) conceptualize information spread as a chain of user-to-user transmissions, where each retweet or share is a probabilistic response to prior exposure. These models often treat retweeters as homogeneous units within the transmission chain, lacking individual or structural specificity (Goel, Kamesh Munagala, et al., 2015; Goel, Anderson, et al., 2015; Kupavskii et al., 2012).

Parallel research has examined the role of influencers in amplifying misinformation, emphasizing users with large follower bases or high centrality in networks (Flaherty & Mangan, 2025). This approach tends to reduce amplification to a function of individual-level reach (Gallagher, 2022), overlooking how groups of retweeters may collectively shape the visibility and longevity of misinformation through patterned co-engagement (Shao et al., 2018).

Recent studies have begun to explore coordinated behaviors among social media users, particularly in the context of political messaging and misinformation. For instance, Pacheco et al. (2021) introduced methods to detect groups of accounts engaging in synchronized activities, highlighting their role in boosting the exposure of low-credibility content. However, such work often focuses on malicious coordination (e.g., bots or trolls) and still rarely treats retweeters as a distinct analytic category whose structural connections can be meaningfully analyzed.

Despite the growing recognition of structural factors in misinformation diffusion, few studies have examined how retweeters themselves—rather than influencers or message originators—form behavioral linkages that serve as amplification backbones. Retweeters are typically treated as anonymous nodes of replication, yet they may form emergent structures through co-dissemination behaviors such as retweeting the same misinformation or retweeting content that quotes or replies to it. These patterns of shared engagement, even when uncoordinated or unintentional, may constitute the behavioral core of sustained amplification.

This study addresses this overlooked area by conceptualizing retweeters not merely as transmission endpoints but as structurally significant actors who collectively construct amplification backbones. By shifting the analytical focus from individual influence to networked behavioral convergence, this research proposes a new framework for understanding the organizational logic that sustains misinformation in social media environments.



While the amplification of misinformation on social media has been extensively studied, much of the existing literature primarily focuses on two areas: the dynamics of information diffusion through cascade models and the influential role of key individuals in spreading content.

Cascade models (like epidemiological model SIR) conceptualize information spread as a chain of user-to-user transmissions, where each retweet or share is a probabilistic response to prior exposure. These models often treat retweeters as homogeneous units within the transmission chain, lacking individual or structural specificity (Goel, Kamesh Munagala, et al., 2015; Goel, Anderson, et al., 2015; Kupavskii et al., 2012). Parallel research has examined the role of influencers in amplifying misinformation, emphasizing users with large follower bases or high centrality in networksndefined. This approach tends to reduce amplification to a function of individual-level reach, overlooking how groups of retweeters may collectively shape the visibility and longevity of misinformation through patterned co-engagement (Shao et al., 2018).

Recent studies have begun to explore coordinated behaviors among social media users, particularly in the context of political messaging and misinformation. For instance, Pacheco et al. (2021) introduced methods to detect groups of accounts engaging in synchronized activities, highlighting their role in boosting the exposure of low-credibility content. However, such work often focuses on malicious coordination (e.g., bots or trolls) and still rarely treats retweeters as a distinct analytic category whose structural connections can be meaningfully analyzed. Despite the growing recognition of structural factors in misinformation diffusion, few studies have examined how retweeters themselves—rather than influencers or message originators—form behavioral linkages that serve as amplification backbones. Retweeters are typically treated as anonymous nodes of replication, yet they may form emergent structures through co-dissemination behaviors such as retweeting the same misinformation or retweeting content that quotes or replies to it. These patterns of shared engagement, even when uncoordinated or unintentional, may constitute the behavioral core of sustained amplification.

This study addresses this overlooked area by conceptualizing retweeters not merely as transmission endpoints but as structurally significant actors who collectively construct amplification backbones. By shifting the analytical focus from individual influence to networked behavioral convergence, this research proposes a new framework for understanding the organizational logic that sustains misinformation in social media environments.

## Network Structures and Co-Dissemination Behaviors

3.  From Co-Dissemination Behaviors to Retweeter Amplification Backbone Networks (How This Study Advances the Field) 明确提出：本研究首次系统性区分了three forms of co-dissemination behaviors（direct retweeting, quoting, replying）。

引入跨学科的计算机网络类比，为不同行为带来的网络结构差异提供解释模型。

引用具体研究，说明为何这种细分可以更好理解信息放大的结构逻辑。

如果你需要，我可以直接按照这个逻辑给你整理好每一部分的完整文本，并补充相应的权威文献和APA引用。你想要直接完整改写一版吗？

Understanding the structural characteristics of misinformation diffusion networks is critical for identifying patterns of spread and potential intervention points. Social Network Analysis (SNA) provides powerful tools to examine network metrics such as density, centralization, and transitivity (Wasserman & Faust, 1994). Recent studies reveal that misinformation networks often exhibit highly centralized structures, enabling faster and broader dissemination through a few influential nodes (Guarino et al., 2020).

An increasingly important area of investigation within this field focuses on the co-dissemination behaviors of users—specifically, how retweeters collectively participate in the spread of misinformation. While early research often concentrated on the role of misinformation originators, subsequent studies have highlighted the critical amplifying function of retweeters (Ferrara, 2020; Shao et al., 2018). These actors are not merely passive intermediaries; their coordinated or patterned behaviors can significantly shape the trajectory and reach of misinformation narratives (Weber & Neumann, 2021).

Co-dissemination behaviors take various forms across social media platforms. For instance, quote retweets enable users to reinterpret or frame misinformation content within new narratives, potentially expanding its appeal and emotional resonance (Zhao & Wang, 2024). Replies, on the other hand, often introduce controversy or debate, which may paradoxically reinforce the visibility and longevity of false narratives (Wu & Shen, 2023). Studies on coordinated behavior further demonstrate that synchronized retweeting patterns, even in the absence of direct coordination, can contribute to the rapid amplification of specific claims (Truong et al., 2021).

Despite growing attention to these behaviors, much of the existing literature tends to treat retweeting as a uniform action without systematically distinguishing between the different relational pathways through which misinformation spreads. This lack of differentiation overlooks important variations in how narratives are amplified, reinterpreted, or contested across user interactions. Addressing this gap, our study builds on prior work to explore how distinguishing between co-dissemination behaviors—such as direct retweeting, quoting, and replying—can offer a more nuanced understanding of misinformation diffusion dynamics.

# Research Method

## Data Source and Collection

The data utilized in this research are collected from the [MuMiN (Multilingual Misinformation Network) dataset](https://mumin-dataset.github.io/), which comprises large-scale misinformation diffusion events on Twitter (now X). Specifically, this study focus on a set of six prominent misinformation claims related to the narrative asserting that [COVID-19 was deliberately created or manufactured by China or a laboratory in Wuhan](https://en.wikipedia.org/wiki/COVID-19_lab_leak_theory) across a time span from March 2020 to August 2021. Each misinformation claim represents a distinct temporal event under the same topic, thus allowing for comparisons across different stages of misinformation dissemination.

## Nodes and Edges Definition

It is not a diffusion network tracing how misinformation flows from one user to another through follower relationships or direct influence.

You are not modeling how information “spreads” across individual pathways or trying to identify classic “influencers” in the sense of high-betweenness or high-follower nodes within a transmission chain.

It is a structural co-behavior network focused on how amplifiers (retweeters) relate to one another through shared amplification behavior.

Edges represent behavioral convergence—i.e., two retweeters acted similarly by amplifying the same misinformation content (directly, through quoting, or replying).

Your goal is to understand how these collective behavioral patterns create structural conditions that either sustain or constrain misinformation amplification, independent of individual follower influence.

This study conceptualizes individual retweeters—users actively involved in the redistribution of misinformation—as foundational units within larger meta-networks of amplification. These retweeter-centric networks, or amplification backbones, capture how collective user behaviors create structural conditions that facilitate or constrain the amplification potential of misinformation, independent of the content itself (Barabási, 2016). Each retweeter is represented as a network node, and relational ties (edges) are defined through three distinct co-retweeting behaviors. To interpret the structural and functional characteristics of the resulting networks, a cross-disciplinary heuristic framework is applied, drawing specifically from principles in computer network engineering. In this framework, the study analogizes retweeter networks to the organizational patterns found in physical network infrastructures, where hubs, switches, and routers perform distinct roles in information transmission and amplification. This interdisciplinary perspective provides a conceptual foundation for understanding the differentiated structural properties and amplification dynamics across the three types of retweeter networks.

### Direct Co-Retweet Network

The first category, Direct Co-Retweet, establishes edges between two retweeters if both have retweeted the exact same misinformation tweet. This behavior reflects the most immediate and synchronous form of information amplification, typically associated with highly reactive and temporally concentrated user engagement (Vosoughi, Roy, & Aral, 2018). Conceptually, this network corresponds to a meta-network of amplification hubs, where retweeters function as hubs and edges represent their frequent co-engagement in amplifying identical misinformation content.

Drawing on computer network engineering principles, this structure is analogous to the interactions among Ethernet hubs. In such environments, hubs indiscriminately broadcast all received data to connected devices (Tanenbaum & Wetherall, 2011). When considering a meta-level perspective, hubs themselves can also be seen as engaging in co-broadcasting behavior—frequently handling and transmitting the same data streams across the network (Kurose & Ross, 2021). Similarly, retweeter hubs that frequently co-retweet the same misinformation content effectively form a densely connected meta-network through these shared amplification events.

This network structure is expected to exhibit high density, as the frequent and indiscriminate co-retweeting behavior creates numerous direct ties among retweeter hubs. However, despite this density, the network is anticipated to have low degree centralization. The dissemination process is horizontally distributed, lacking reliance on a small set of dominant actors. In such flat structures, no single retweeter disproportionately influences the amplification process, mirroring how Ethernet hubs operate without prioritizing specific nodes (Forouzan, 2017).

Finally, the clustering coefficient is expected to remain low. Although the network is dense, these connections emerge primarily from transient, event-driven co-amplification rather than stable or cohesive subgroup formations. Similar to how broadcast redundancy in Ethernet hubs increases traffic but does not foster tightly-knit clusters, retweeters in direct co-retweet networks exhibit high connectivity without forming persistent triadic relationships (Barabási, 2016; Newman, 2010).

### Quote Pathway Co-Retweet

The second category, quote pathway co-retweet, forms edges between two retweeters if both have retweeted either the original misinformation tweet or any tweet explicitly quoting it. This behavior introduces an additional narrative layer, where misinformation is not simply repeated but often reframed or recontextualized, amplifying its persuasive power through reinterpretation and added commentary (Papacharissi & de Fatima Oliveira, 2012).

At the meta-network level, this structural pattern corresponds to how Ethernet switches coordinate with one another through selective forwarding strategies. In network architecture, switches do not indiscriminately broadcast information like hubs but instead intelligently manage traffic by forwarding data packets to specific destinations based on address information (Stallings, 2020). When viewed from a meta-network perspective, switches that frequently participate in the forwarding of similar high-level data streams (e.g., similar content types or priority flows) form structured pathways that optimize information exchange across the broader network (Kurose & Ross, 2021). Similarly, retweeter hubs engaged in quote retweet behaviors form connections not through direct repetition but through shared amplification of interpretive or reframed misinformation content, fostering more purposeful but selective ties across the meta-network.

This structural logic suggests a moderate density within quote pathway co-retweet networks compared to direct co-retweet network. While engagement remains significant, the selective nature of quoting (forwarding data packets to specific destinations) introduces filtering mechanisms that reduce indiscriminate content propagation (Tanenbaum & Wetherall, 2011). Additionally, these networks are expected to exhibit moderate degree centralization. Certain influential actors whose reinterpretations or commentaries resonate widely may emerge as interpretive leaders. However, the absence of rigid hierarchical pathways means that overall centralization remains less pronounced compared to highly stratified networks (Forouzan, 2017).

Notably, quote-based networks are hypothesized to display a moderate to high clustering coefficient. Unlike direct retweeting, quoting inherently introduces an additional layer of selective engagement, where users actively choose not only to propagate misinformation but also to reframe it within specific narrative contexts. This behavior fosters the emergence of localized interpretive communities, where users repeatedly interact with others who share similar viewpoints or rhetorical framings of the misinformation narrative (Papacharissi, 2015). As these shared interpretive practices accumulate, the likelihood of triadic closure among users increases, leading to tightly-knit subgroups centered around influential reframings. This pattern parallels the formation of Virtual Local Area Networks (VLANs) in computer network architecture, where Ethernet switches logically segment larger networks into smaller, cohesive subnetworks. These subnetworks facilitate more frequent and efficient data exchanges among devices within the same logical group, even if they are physically dispersed (Perlman, 1985; Kurose & Ross, 2021). Similarly, retweeter hubs participating in quoting behaviors selectively engage with content that resonates within specific narrative frames, effectively constructing “interpretive subnetworks” within the broader misinformation amplification meta-network.

### Reply Pathway Co-Retweet

The third category, reply pathway co-retweet, forms edges when two retweeters have either retweeted the original misinformation tweet or a tweet explicitly replying to it. This behavior represents a higher level of interactive engagement, often characterized by public debates, emotional reactions, and efforts to contest or clarify misinformation narratives. Empirical studies indicate that reply chains, particularly around controversial content, foster emotionally charged discussions and recursive interactions, intensifying user clustering around specific conversational threads (Chuai et al., 2024; Fazio et al., 2015).

In this meta-network of retweeters, reply-based connections closely mirror the behavior of core routers in computer network infrastructures. These routers do not simply relay information to endpoints but serve as critical junctions that interconnect subnetworks, efficiently managing large-scale traffic flows and concentrating communication through pivotal nodes (Stallings, 2020). Similarly, influential retweeters in reply networks often occupy structurally central positions, acting as conversational hubs that bridge otherwise disconnected retweeter communities and facilitate cross-cluster narrative circulation (Freeman, 1979).

Accordingly, reply-path co-retweet networks are expected to exhibit low global density but high local clustering and degree centralization. In this meta-network of retweeters, edges emerge from shared engagement with specific reply chains linked to misinformation narratives. This structural configuration reflects how user participation in reply-based dissemination tends to concentrate around focused conversational threads, leading to the formation of tightly knit local discussion clusters. Analogous to how routers in computer networks manage information flow between distinct subnetworks, certain highly active retweeters function as bridging hubs, connecting otherwise fragmented communities by amplifying reply-thread content across broader audience segments. This contributes to a network structure characterized by high clustering coefficients and the presence of central nodes that facilitate cross-group information circulation, even as overall connection density remains low.

Thus, each co-retweeting behavior produces a distinct network topology, operationalized through separate adjacency matrices, and analyzed across six temporally distinct misinformation claim related to the same topic. These conceptual distinctions provide insight into how different dissemination behaviors shape the structural organization of retweeter amplification networks, revealing how collective retweeter behaviors manifest in varying patterns of density, centralization, and clustering coefficient within these meta-networks of amplification.

## Analytical Strategy and Network Metrics

Social Network Analysis (SNA) techniques are systematically applied to evaluate structural properties of the retweeter networks constructed from each co-dissemination behavior. Specifically, this study focuses on three primary structural metrics:

1.  Network Density, which measures the proportion of actual connections to all possible connections among retweeters, indicating the overall intensity of collective dissemination.

2.  Transitivity (Global Clustering Coefficient), capturing the extent to which retweeters tend to cluster into tightly interconnected groups, reflecting localized amplification dynamics.

3.  Degree Centralization (Freeman’s Centralization), assessing the degree to which networks are structurally centralized around influential retweeters or "hubs," potentially highlighting core influencers in misinformation propagation.

## Hypotheses

Based on our research question and theoretical considerations, this study proposes the following hypotheses regarding structural differences among the three co-retweet networks:

**H1 (Density):** *Direct co-retweet networks exhibit significantly higher density and average degree compared to quote and reply pathway networks.*

This hypothesis is grounded in the assumption that direct co-retweeting, as a more explicit form of simultaneous engagement, leads to denser connections among retweeters.

**H2 (Centralization):** *Quote and reply pathway co-retweet networks exhibit significantly higher degree centralization compared to direct co-retweet networks.*

This hypothesis anticipates that retweeters engaging in secondary dissemination behaviors (quote or reply) form more centralized structures, driven by influential actors shaping the interpretation or discussion around misinformation.

**H3 (Transitivity):** *Quote pathway co-retweet networks demonstrate higher transitivity (global clustering coefficient), reflecting tighter subgroup clustering compared to direct and reply pathway networks.*

We posit that quote-based retweeting, which inherently involves reinterpretation or reframing of content, fosters greater clustering among subsets of retweeters.

**H4 (Core Node Formation):** *Reply pathway co-retweet networks are more likely to exhibit clear core-periphery structures, featuring prominent central nodes (influential retweeters), compared to direct or quote pathway networks.*

This hypothesis aligns with the interactive nature of reply-based dissemination, where debates and discussions can amplify the prominence of certain users.

**H5 (Temporal Variation):** *The structural characteristics (density, transitivity, and centralization) of co-retweet networks significantly vary across different temporal misinformation events.*

Specifically, early-stage misinformation claims are hypothesized to produce denser and more centralized retweeter networks compared to claims disseminated at later stages, reflecting early retweeters' structural advantage in amplifying misinformation narratives.

These hypotheses are systematically tested through the comparative network analyses and statistical approaches outlined in this methods section.

## Comparative Statistical Analysis

To rigorously assess the differences among the three types of co-retweet networks, statistical analyses are conducted as follows:

Firstly, descriptive statistics are computed to characterize the structural metrics (density, transitivity, and centralization) for each network type. Subsequently, pairwise t-tests and analysis of variance (ANOVA) are utilized to evaluate whether differences in structural metrics across network types are statistically significant.

To further validate the clustering patterns observed, Conditional Uniform Graph (CUG) tests are employed. CUG tests specifically determine whether the observed transitivity (clustering) within each retweeter network significantly exceeds expectations under random graph scenarios, thus confirming whether observed clustering is structurally meaningful rather than attributable to random chance.

## Temporal Comparative Analysis

Considering that the misinformation claims occurred at distinct time points, this study leverages the temporal dimension inherent in the dataset. Each misinformation claim is analyzed separately, resulting in six temporal events. Given the three co-retweet behaviors, a total of 18 sub-networks (6 misinformation events × 3 co-retweet behaviors) are analyzed.

Comparative analyses across these temporal sub-networks are conducted to identify structural variations over time. Specifically, structural metrics (density, transitivity, centralization) are compared across earlier versus later misinformation events. The goal is to explore whether earlier-stage misinformation claims form structurally distinct retweeter networks, potentially indicating differences in amplification dynamics across misinformation lifecycle stages.

## Exploratory Exponential Random Graph Models (ERGMs)

While detailed node attribute data are limited in our dataset, exploratory Exponential Random Graph Models (ERGMs) are additionally employed to understand underlying structural mechanisms influencing network formation. These ERGMs focus primarily on structural features, such as edges, degree distributions, and transitivity, to provide insights into fundamental network-generating processes driving tie formation among retweeters. Although exploratory, these models serve as valuable robustness checks that complement our descriptive and comparative findings.

## Tools

All data processing, network construction, and analysis procedures were conducted using the RStudio (version \>= 4.0.0), primarily leveraging the `statnet` family of packages for network analysis, along with auxiliary packages for statistical testing (`stats` etc.) and data visualization (`ggplot2` etc.).

# Analysis

## Basic Network Metrics

### Compare 3 Networks overall difference

```{r}
adj_direct <- as.matrix(read.csv("data/adj_matrix_co_retweet.csv", row.names = 1, check.names = FALSE))
adj_quote <- as.matrix(read.csv("data/adj_matrix_co_retweet_quote_path.csv", row.names = 1, check.names = FALSE))
adj_reply <- as.matrix(read.csv("data/adj_matrix_co_retweet_reply_path.csv", row.names = 1, check.names = FALSE))

net_direct <- network(adj_direct, directed = FALSE, matrix.type = "adjacency")
net_quote <- network(adj_quote, directed = FALSE, matrix.type = "adjacency")
net_reply <- network(adj_reply, directed = FALSE, matrix.type = "adjacency")

compute_network_metrics <- function(net) {
  data.frame(
    Nodes = network.size(net),
    Edges = network.edgecount(net),
    Density = gden(net),
    Average_Degree = mean(degree(net), na.rm = TRUE),
    Transitivity = gtrans(net, mode = "graph"),
    Centralization_Degree = centralization(net, degree, mode = "freeman")
  )
}

metrics_direct <- compute_network_metrics(net_direct)
metrics_quote <- compute_network_metrics(net_quote)
metrics_reply <- compute_network_metrics(net_reply)

metrics_result <- rbind(
  cbind(Network = "Direct Co-Retweet", metrics_direct),
  cbind(Network = "Quote Pathway", metrics_quote),
  cbind(Network = "Reply Pathway", metrics_reply)
)

print(metrics_result)

# plot(net_direct)
# plot(net_quote)
# plot(net_reply)
```

# Reference

Barabási, A.-L. (2016). Network science. Cambridge University Press. https://www.cambridge.org/fr/academic/subjects/physics/statistical-physics/network-science?format=HB&isbn=9781107076266

Bruns, A., Harrington, S., & Hurcombe, E. (2020). Corona? 5G? or both? The dynamics of COVID-19 conspiracy theories on Facebook. *Media International Australia, 177*(1), 12–29. <https://doi.org/10.1177/1329878X20946113>

Chuai, Y., Sergeeva, A., Lenzini, G., & Pröllochs, N. (2024). Community fact-checks trigger moral outrage in replies to misleading posts on social media (arXiv preprint arXiv:2409.08829). https://arxiv.org/abs/2409.08829

Cinelli, M., Quattrociocchi, W., Galeazzi, A., et al. (2020). The COVID-19 social media infodemic. *Scientific Reports, 10*, 16598. <https://doi.org/10.1038/s41598-020-73510-5>

Fazio, L. K., Brashier, N. M., Payne, B. K., & Marsh, E. J. (2015). Knowledge does not protect against illusory truth. Journal of Experimental Psychology: General, 144(5), 993–1002. https://doi.org/10.1037/xge0000098

Ferrara, E. (2020). What types of COVID-19 conspiracies are populated by Twitter bots? *First Monday, 25*(6). <https://doi.org/10.5210/fm.v25i6.10633>

Freeman, L. C. (1979). Centrality in social networks: Conceptual clarification. Social Networks, 1(3), 215–239. https://doi.org/10.1016/0378-8733(78)90021-7

Forouzan, B. A. (2017). Data Communications and Networking (5th ed.). McGraw-Hill Education.

Guarino, S., Trino, N., Celestini, A., Chessa, A., & Riotta, G. (2020). Characterizing networks of propaganda on Twitter: A case study. *Applied Network Science, 5*, 59. <https://doi.org/10.1007/s41109-020-00286-y>

Guess, A., Nagler, J., & Tucker, J. (2019). Less than you think: Prevalence and predictors of fake news dissemination on Facebook. *Science Advances, 5*(1), eaau4586. <https://doi.org/10.1126/sciadv.aau4586>

Klein, B. (2022). The network structure of online amplification (Doctoral dissertation, Northeastern University). Retrieved from https://repository.library.northeastern.edu/files/neu:4f186q93m/fulltext.pdf

Kurose, J. F., & Ross, K. W. (2021). Computer Networking: A Top-Down Approach (8th ed.). Pearson.

Papacharissi, Z. (2015). Affective Publics: Sentiment, Technology, and Politics. Oxford University Press.

Papacharissi, Z., & de Fatima Oliveira, M. (2012). Affective news and networked publics: The rhythms of news storytelling on #egypt. Journal of Communication, 62(2), 266–282. https://doi.org/10.1111/j.1460-2466.2012.01630.x

Perlman, R. (1985). An algorithm for distributed computation of a spanning tree in an extended LAN. ACM SIGCOMM Computer Communication Review, 15(4), 44–53. https://doi.org/10.1145/319056.319004

Shao, C., Ciampaglia, G. L., Varol, O., et al. (2018). The spread of low-credibility content by social bots. *Nature Communications, 9*, 4787. <https://doi.org/10.1038/s41467-018-06930-7>

Stallings, W. (2020). Data and computer communications (11th ed.). Pearson.

Stam, C., Saldanha, E., Halappanavar, M., & Acharya, A. (2024). DISHONEST: Dissecting misinformation spread using homogeneous social networks and semantic topic classification. arXiv preprint arXiv:2412.09578. https://arxiv.org/abs/2412.09578

Tanenbaum, A. S., & Wetherall, D. J. (2011). Computer networks (5th ed.). Pearson.

Truong, B. T., Hui, P.-M., Torres-Lugo, C., Pacheco, D., Flammini, A., & Menczer, F. (2021). Uncovering coordinated networks on social media. Proceedings of the International AAAI Conference on Web and Social Media, 15(1), 455–466. https://doi.org/10.1609/icwsm.v15i1.18075

Vosoughi, S., Roy, D., & Aral, S. (2018). The spread of true and false news online. *Science, 359*(6380), 1146–1151. <https://doi.org/10.1126/science.aap9559>

Wasserman, S., & Faust, K. (1994). *Social Network Analysis: Methods and Applications*. Cambridge University Press.

Weber, D., & Neumann, F. (2021). Amplifying influence through coordinated behaviour in social networks. Social Network Analysis and Mining, 11(1), 1–13. https://doi.org/10.1007/s13278-021-00815-2

Wu, Y., & Shen, H. (2023). Examining retweeting behavior on social networking sites from the perspective of online identity and self-presentation. Frontiers in Psychology, 14, 10202284. https://doi.org/10.3389/fpsyg.2023.10202284

Yan, Y., Toriumi, F., & Sugawara, T. (2021). Understanding how retweets influence the behaviors of social networking service users via agent-based simulation. Computational Social Networks, 8(1), 18. https://doi.org/10.1186/s40649-021-00099-8

Zhao, Z., & Wang, X. (2024). To Reply or to Quote: Comparing conversational framing strategies on Twitter. Proceedings of the ACM on Human-Computer Interaction, 8(CSCW1), Article 3625680. https://doi.org/10.1145/3625680

# Appendix

## Data Collection

This study uses secondary data from the **MuMiN Project** (Multi-platform Misinformation Influence Network), publicly available at: <https://data.bris.ac.uk/datasets/23yv276we2mll25fjakkfim2ml/mumin.zip> The dataset includes information about retweeter ids, tweets ids, misinformation claims, and the date when specific misinformation claims uttered etc.

**Note: About the `date`, [the explanation of dataset's authours](https://arxiv.org/abs/2202.11684):**

*"`date`: The date the claim was uttered. If this date was not available then the date of the review was used. If neither of those two were available then we extracted a potential date from the URL of the fact-checking article using the regular expression \[0-9\]{4}-\[0-9\]{2}-\[0-9\]{2}."*

After downloading all files, create a `data` folder in your working directory and place the files inside it. Then, follow the setup instructions provided [here](https://colab.research.google.com/drive/1JCjgg3moGBOuZk4iVjBpQNqgsAYFyNoS#scrollTo=YS1uxj-59UmA). Use the shell to install required packages via `pip` as directed. Next, open `VS Code`, and run the following Python script to convert `.pkl` files to `.csv`:

```{python}
#| eval: false
#| include: true

import pandas as pd
import os

input_dir = "data/mumin"
output_dir = "data/mumin_csv"
os.makedirs(output_dir, exist_ok=True)

file_names = [
    "claim",
    "user",
    "tweet",
    "reply",
    "article",
    "tweet_discusses_claim",
    "article_discusses_claim",
    "user_follows_user",
    "user_retweeted_tweet",
    "reply_quote_of_tweet",
    "reply_reply_to_tweet"
]

for name in file_names:
    input_path = os.path.join(input_dir, name)
    output_path = os.path.join(output_dir, f"{name}.csv")
    try:
        df = pd.read_pickle(input_path, compression="xz")
        df.to_csv(output_path, index=False)
        print(f"Saved: {output_path}")
    except Exception as e:
        print(f"Failed to convert {name}: {e}")

```

This script will generate the corresponding CSV files for further analysis.

**Note:** *If you have a [X Developer API Pro Account](https://developer.x.com/en/portal/products/pro), you can directly follow the dataset's authors' [MuMiN Tutorial](https://colab.research.google.com/drive/1JCjgg3moGBOuZk4iVjBpQNqgsAYFyNoS#scrollTo=YS1uxj-59UmA) and conduct a deeper analysis with more enriched variables when [rehydrating the original datasets](https://colab.research.google.com/drive/1JCjgg3moGBOuZk4iVjBpQNqgsAYFyNoS#scrollTo=bOQqaJOa_PbF&line=1&uniqifier=1).*

After all steps above done, you can review the data in R:

```{r}
#| eval: false
#| include: true
# Set the data path 
data_path <- "data/mumin_csv/"

# Define the list of files to read
files <- c(
  "claim.csv", "user.csv", "tweet.csv", "reply.csv", "article.csv",
  "tweet_discusses_claim.csv", "article_discusses_claim.csv",
  "user_follows_user.csv", "user_retweeted_tweet.csv",
  "reply_quote_of_tweet.csv", "reply_reply_to_tweet.csv"
)

# Preview the first few rows of each file 
previews <- lapply(files, function(fname) {
  fpath <- file.path(data_path, fname)
  tryCatch(
    read_csv(fpath, n_max = 5),
    error = function(e) tibble::tibble(error = paste("Error:", e$message))
  )
})

names(previews) <- files

```

## Data Preparation

### Loading Required Packages

```{r}
#| eval: false
library(tidyverse)
library(readr)
library(statnet)
library(intergraph)
library(reshape2)
library(btergm)
library(igraph)
```

### Loading and Merging Data

```{r}
#| output: false
# Load data
tweets <- read_csv("data/mumin_csv/tweet.csv")
claims <- read_csv("data/mumin_csv/claim.csv")
tweet_claim <- read_csv("data/mumin_csv/tweet_discusses_claim.csv")
user_retweet <- read_csv("data/mumin_csv/user_retweeted_tweet.csv")

# Join tweet & claim via tweet_claim
tweet_claim_joined <- tweet_claim |> 
  rename(tweet_id = src, claim_id = tgt) |> 
  inner_join(claims, by = c("claim_id" = "id"))

# Join retweeters within users & claim via retweeted tweet
user_claim <- user_retweet |> 
  rename(retweeter_id = src, tweet_id = tgt) |> 
  inner_join(tweet_claim_joined, by = "tweet_id")

# Create a mapping of retweeters and tweets
retweet_map <- user_claim |> 
  select(retweeter_id, tweet_id) |> 
  distinct() 

# Basic data overview
table(user_claim$label)
head(table(user_claim$cluster_keywords))
```

### Filtering for Target Misinformation Narratives

This study focuses specifically on misinformation narratives claiming that **COVID-19 was deliberately created or spread by China or the Wuhan laboratory**. The following filtering steps were applied:

```{r}
#| output: false
# Filter keywords containing "china" or "wuhan"
user_claim_filtered <- user_claim |> 
  filter(str_detect(keywords, "china|wuhan")) 

head(unique(user_claim_filtered$keywords))

# Manually select misinformation topics directly related to the COVID-19 origin narrative
covid_wuhan_misinfo <- user_claim_filtered |>
  filter(keywords %in% c(
    "coronavirus comes biological laboratory wuhan",
    "including corona virus manufactured wuhan",
    "china created spread coronavirus",
    "announced coronavirus artificially created china",
    "china created coronavirus",
    "coronavirus created laboratory china",
    "honjo said china manufactured coronavirus",
    "said new coronavirus manufactured wuhan",
    "coronavirus tested biological weapon china",
    "china testing coronavirus biological weapon",
    "covid 19 lab china",
    "coronavirus natural worked wuhan laboratory",
    "coronavirus manufactured laboratory wuhan specifically",
    "doctor claimed coronavirus china create",
    "corona virus manufactured china",
    "says current coronavirus manufactured wuhan",
    "wuhan coronavirus created patented",
    "covid 19 disease manufactured china",
    "pandemic caused artificial virus china",
    "collaborator assures coronavirus manufactured wuhan",
    "concluded covid leaked wuhan lab",
    "coronavirus created united states china",
    "air comes china import coronavirus",
    "coronavirus released china"
  )) |>
  # Restrict the analysis to English-language posts labeled as "misinformation"
  filter(language == "en") |>
  filter(label == "misinformation")

# Distribution of final misinformation topics
table(covid_wuhan_misinfo$keywords)
table(covid_wuhan_misinfo$cluster_keywords)
```

## Social Network Construction

This network models the co-dissemination behavior of misinformation retweeters. While the exact paths of information transmission are unknown, this co-spreader network captures the structural relationships that may facilitate misinformation diffusion.

### Co-Retweet Network

The `co-retweet` network represents a co-dissemination behavior among retweeters. A tie is created between two users only if they both retweeted the same specific misinformation tweet, which is identified by a shared `tweet_id` in `user_retweeted_tweet.csv` file. Each edge is weighted by the number of such co-retweeting events, reflecting how often the same pair of users jointly retweeted the same pieces of misinformation. Though this relationship does not suggest that a paired users share the same opinion, it captures direct and synchronous amplification of specific misinformation claim in tweets. Therefore, by analyzing the weighted connections among pairs of retweeters, this network checks which retweeters are central to the misinformation amplification/dissemination process, and whether specific communities or cliques form around the repeated propagation of misinformation.

```{r}
#| output: false
# Extract misinformation-related tweets id
misinfo_tweet_id <- unique(covid_wuhan_misinfo$tweet_id)

# Identify pairs of users who co-retweeted the same misinformation tweet
co_retweet_edges <- user_retweet |> 
  filter(tgt %in% misinfo_tweet_id) |> 
  rename(tweet_id = tgt, retweeter_id = src) |> 
  group_by(tweet_id) |> 
  summarise(
    pairs = list(as.data.frame(t(combn(retweeter_id, 2)))), 
    .groups = "drop"
  ) |> 
  unnest(pairs) |> 
  mutate(
    user_1 = pmin(V1, V2), # Ensure lower ID comes first
    user_2 = pmax(V1, V2) # Ensure higher ID comes second
  ) |> 
  select(user_1, user_2) |> 
  group_by(user_1, user_2) |> 
  summarise(weight = n(), .groups = "drop") |> 
  mutate(type = "co-retweet") |>
  filter(user_1 != user_2) |>
  mutate(
    user_1 = as.character(user_1),
    user_2 = as.character(user_2)
  )

# Obtain the full list of unique users involved
all_retweeters <- unique(c(
  covid_wuhan_misinfo$retweeter_id,  
  co_retweet_edges$user_1, 
  co_retweet_edges$user_2
)) |> 
  as.character() |> 
  sort()

# Create initial matrix
adj_matrix_co_retweet <- acast(
  co_retweet_edges, 
  user_1 ~ user_2, 
  value.var = "weight", 
  fill = 0
)

# Ensure matrix completeness by adding missing rows and columns
missing_rows <- setdiff(all_retweeters, rownames(adj_matrix_co_retweet))
missing_cols <- setdiff(all_retweeters, colnames(adj_matrix_co_retweet))

if (length(missing_rows) > 0) {
  adj_matrix_co_retweet <- rbind(
    adj_matrix_co_retweet, 
    matrix(0, nrow = length(missing_rows), ncol = ncol(adj_matrix_co_retweet), 
           dimnames = list(missing_rows, colnames(adj_matrix_co_retweet)))
  )
}

if (length(missing_cols) > 0) {
  adj_matrix_co_retweet <- cbind(
    adj_matrix_co_retweet, 
    matrix(0, nrow = nrow(adj_matrix_co_retweet), ncol = length(missing_cols), 
           dimnames = list(rownames(adj_matrix_co_retweet), missing_cols))
  )
}

# Reorder the matrix to align rows and columns
adj_matrix_co_retweet <- adj_matrix_co_retweet[all_retweeters, all_retweeters]

# Export the adjacency matrix for further analysis
write.csv(adj_matrix_co_retweet, "data/adj_matrix_co_retweet.csv", row.names = TRUE)

# Check dimensions of the final matrix
ncol(adj_matrix_co_retweet)
nrow(adj_matrix_co_retweet)

table(co_retweet_edges$weight)
```

### Co-Retweet (Quote Pathway)

The **Co-Retweet (Quote Pathway)** Network captures relational ties between users who both engaged in the dissemination (i.e., retweeting) of misinformation content either by a) retweeting original misinformation tweets, or b) retweeting tweets that explicitly quoting misinformation tweets. In this network, a tie is formed between two users if they each retweeted at least one tweet that is either a misinformation tweet or a tweet quoting misinformation pieces.

```{r}
# Load quote relationships between tweets (quoting tweet & quoted tweet)
quote_relations <- read_csv("data/mumin_csv/reply_quote_of_tweet.csv") |>
  filter(tgt %in% misinfo_tweet_id | src %in% misinfo_tweet_id) |> 
  rename(
    quoted_tweet_id = tgt, # The misinformation tweet being quoted
    quoting_tweet_id = src # The tweet that quotes the misinformation tweet
  )

# Create the complete set of tweets relevant to the quote pathway
quote_path_tweet_ids <- unique(c(
  quote_relations$quoted_tweet_id , # Original misinformation tweets
  quote_relations$quoting_tweet_id # Tweets that quoted misinformation
))

# Find all users who retweeted these tweets
quote_path_retweets <- covid_wuhan_misinfo |> 
  filter(tweet_id %in% quote_path_tweet_ids) 

# Generate co-retweet edges based on shared retweeting of these tweets
co_retweet_quote_path_edges <- quote_path_retweets |>
  group_by(tweet_id) |>
  summarise(
    pairs = list(as.data.frame(t(combn(retweeter_id, 2)))), 
    .groups = "drop"
  ) |>
  unnest(pairs) |>
  mutate(
    user_1 = pmin(V1, V2),
    user_2 = pmax(V1, V2)
  ) |>
  select(user_1, user_2) |>
  group_by(user_1, user_2) |>
  summarise(weight = n(), .groups = "drop") |>
  mutate(type = "co-retweet-quote-path") |>
  filter(user_1 != user_2) |> 
  mutate(
    user_1 = as.character(user_1),
    user_2 = as.character(user_2)
  )

# Prepare full user list
all_retweeters_quote <- unique(c(
  covid_wuhan_misinfo$retweeter_id, 
  co_retweet_quote_path_edges$user_1, 
  co_retweet_quote_path_edges$user_2
)) |> 
  as.character() |> 
  sort()

# Create the adjacency matrix
adj_matrix_co_retweet_quote_path <- acast(
  co_retweet_quote_path_edges, 
  user_1 ~ user_2, 
  value.var = "weight", 
  fill = 0
)

# Add missing rows and columns to complete the matrix
missing_rows <- setdiff(all_retweeters_quote, rownames(adj_matrix_co_retweet_quote_path))
missing_cols <- setdiff(all_retweeters_quote, colnames(adj_matrix_co_retweet_quote_path))

if (length(missing_rows) > 0) {
  adj_matrix_co_retweet_quote_path <- rbind(
    adj_matrix_co_retweet_quote_path, 
    matrix(0, nrow = length(missing_rows), ncol = ncol(adj_matrix_co_retweet_quote_path), 
           dimnames = list(missing_rows, colnames(adj_matrix_co_retweet_quote_path)))
  )
}

if (length(missing_cols) > 0) {
  adj_matrix_co_retweet_quote_path <- cbind(
    adj_matrix_co_retweet_quote_path, 
    matrix(0, nrow = nrow(adj_matrix_co_retweet_quote_path), ncol = length(missing_cols), 
           dimnames = list(rownames(adj_matrix_co_retweet_quote_path), missing_cols))
  )
}

# Ensure matrix symmetry and proper ordering
adj_matrix_co_retweet_quote_path <- adj_matrix_co_retweet_quote_path[all_retweeters_quote, all_retweeters_quote]

# Save the matrix for further analysis
write.csv(adj_matrix_co_retweet_quote_path, "data/adj_matrix_co_retweet_quote_path.csv", row.names = TRUE)

# Output matrix dimensions for verification
nrow(adj_matrix_co_retweet_quote_path)
ncol(adj_matrix_co_retweet_quote_path)

table(co_retweet_quote_path_edges$weight)

```

```{r}
quote_data <-read_csv("data/mumin_csv/reply_quote_of_tweet.csv")

sum(quote_data$src %in% misinfo_tweet_id)

sum(quote_data$tgt %in% misinfo_tweet_id)

sum(misinfo_tweet_id %in% quote_data$tgt)

sum(misinfo_tweet_id %in% c(quote_data$src,quote_data$tgt))

```

### Co-Retweet (Reply Pathway)

The **Co-Retweet (Reply Pathway)** Network captures relational ties between users who both retweeted tweets directly involved in misinformation discussions, either by a) retweeting misinformation tweets themselves, or b) retweeting the tweets that explicitly replied to such misinformation content.

```{r}
# Load reply relationships to identify reply chains around misinformation
reply_relations <- read_csv("data/mumin_csv/reply_reply_to_tweet.csv") |>
  filter(tgt %in% misinfo_tweet_id | src %in% misinfo_tweet_id) |> 
  rename(
    replied_tweet_id = tgt, # The misinformation tweet being replied to
    replying_tweet_id = src # The tweet that replies to the misinformation tweet
  )

# Step 1: Create complete set of tweets involved in reply chains related to misinformation
reply_path_tweet_ids <- unique(c(
  reply_relations$replied_tweet_id, 
  reply_relations$replying_tweet_id
))

# Step 2: Find all users who retweeted these tweets (participating in the reply pathway)
reply_path_retweets <- covid_wuhan_misinfo |> 
  filter(tweet_id %in% reply_path_tweet_ids)

# Step 3: Generate Co-Reply Edges based on shared retweeting of reply-path tweets
co_retweet_reply_path_edges <- reply_path_retweets |>
  group_by(tweet_id) |>
  summarise(
    pairs = list(as.data.frame(t(combn(retweeter_id, 2)))), 
    .groups = "drop"
  ) |>
  unnest(pairs) |>
  mutate(
    user_1 = pmin(V1, V2), 
    user_2 = pmax(V1, V2)
  ) |>
  select(user_1, user_2) |>
  group_by(user_1, user_2) |>
  summarise(weight = n(), .groups = "drop") |>
  mutate(type = "co-retweet-reply-path") |>
  filter(user_1 != user_2) |>
  mutate(
    user_1 = as.character(user_1),
    user_2 = as.character(user_2)
  )

# Prepare full user list
all_retweeters_reply <- unique(c(
  covid_wuhan_misinfo$retweeter_id, 
  co_retweet_reply_path_edges$user_1, 
  co_retweet_reply_path_edges$user_2
)) |> 
  as.character() |> 
  sort()

# Create the adjacency matrix
adj_matrix_co_retweet_reply_path <- acast(
  co_retweet_reply_path_edges, 
  user_1 ~ user_2, 
  value.var = "weight", 
  fill = 0
)

# Add missing rows and columns to complete the matrix
missing_rows <- setdiff(all_retweeters_reply, rownames(adj_matrix_co_retweet_reply_path))
missing_cols <- setdiff(all_retweeters_reply, colnames(adj_matrix_co_retweet_reply_path))

if (length(missing_rows) > 0) {
  adj_matrix_co_retweet_reply_path <- rbind(
    adj_matrix_co_retweet_reply_path, 
    matrix(0, nrow = length(missing_rows), ncol = ncol(adj_matrix_co_retweet_reply_path), 
           dimnames = list(missing_rows, colnames(adj_matrix_co_retweet_reply_path)))
  )
}

if (length(missing_cols) > 0) {
  adj_matrix_co_retweet_reply_path <- cbind(
    adj_matrix_co_retweet_reply_path, 
    matrix(0, nrow = nrow(adj_matrix_co_retweet_reply_path), ncol = length(missing_cols), 
           dimnames = list(rownames(adj_matrix_co_retweet_reply_path), missing_cols))
  )
}

# Ensure matrix symmetry and proper ordering
adj_matrix_co_retweet_reply_path <- adj_matrix_co_retweet_reply_path[all_retweeters_reply, all_retweeters_reply]

# Save the matrix for further analysis
write.csv(adj_matrix_co_retweet_reply_path, "data/adj_matrix_co_retweet_reply_path.csv", row.names = TRUE)

# Output matrix dimensions for verification
nrow(adj_matrix_co_retweet_reply_path)
ncol(adj_matrix_co_retweet_reply_path)

table(co_retweet_reply_path_edges$weight)
```

### Extra EDA

#### Followship

A directed edge from User A to User B indicates that User A follows User B. This network captures the potential flow of influence among misinformation retweeters and allows for the identification of opinion leaders and hierarchical structures in misinformation diffusion.

```{r}
# Load retweeter list
retweeter_id_misinfo <- unique(covid_wuhan_misinfo$retweeter_id) |>
  as.character()

# Load and filter directed follow edges
retweeter_follow_edges_directed <- read_csv("data/mumin_csv/user_follows_user.csv") |> 
  rename(follower = src, followee = tgt) |> 
  filter(follower %in% retweeter_id_misinfo & followee %in% retweeter_id_misinfo) |> 
  mutate(weight = 1, type = "follow_directed") |> 
  select(follower, followee, weight, type)

# Check if any edges exist
if (nrow(retweeter_follow_edges_directed) == 0) {
  message("No directed follow relationships found among misinformation retweeters.")
} else {
  # Create adjacency matrix
  all_retweeters <- sort(unique(c(
    covid_wuhan_misinfo$retweeter_id, 
    retweeter_follow_edges_directed$follower, 
    retweeter_follow_edges_directed$followee
  ))) |> as.character()

  adj_matrix_follow_directed <- matrix(
    0, 
    nrow = length(all_retweeters), 
    ncol = length(all_retweeters),
    dimnames = list(all_retweeters, all_retweeters)
  )

  # Fill matrix with edges
  apply(retweeter_follow_edges_directed, 1, function(row) {
    adj_matrix_follow_directed[row["follower"], row["followee"]] <<- 1
  })

  # Save matrix
  write.csv(adj_matrix_follow_directed, "data/adj_matrix_follow_directed.csv", row.names = TRUE)
}
```

Analysis of the follower network among misinformation retweeters revealed no recorded follower-followee relationships within this group. This indicates that users involved in the dissemination of COVID-19 origin misinformation acted largely as isolated agents rather than as members of a tightly connected social network. Such a pattern suggests that the spread of misinformation in this case was driven primarily by content virality and opportunistic engagement, rather than through established social ties or influencer-led dissemination.

#### Follower Counts

```{r}
# Grab Follower Counts for each nodes
follow_data <- read_csv("data/mumin_csv/user_follows_user.csv") |>
  mutate(tgt = as.character(tgt))

follower_counts <- follow_data |> 
  filter(tgt %in% retweeter_id_misinfo) |> 
  count(tgt, name = "follower_count") |> 
  rename(retweeter_id = tgt) 
  
sum(retweeter_id_misinfo %in% follow_data$tgt)

follower_counts_full <- tibble(retweeter_id = retweeter_id_misinfo) |> 
  left_join(follower_counts, by = "retweeter_id") |> 
  replace_na(list(follower_count = 0)) |>
  arrange(desc(follower_count))

```

The follower count data is used here not to identify influencers, but to characterize the composition of the amplifier backbone. In our context, we are not asking “Who can spread misinformation most effectively to a large audience?”

Instead, we can check: **Do the structural patterns of amplifier co-behavior suggest reliance on high-profile nodes, or do they reveal decentralized, echo-chamber-like clusters of low-profile actors?**

According to our output, among the 112 retweeters involved in misinformation amplification reveals a highly polarized distribution. Specifically, only 8 retweeters have a modest following of 1–2 followers, while a single retweeter holds a disproportionately large follower base of 229. The remaining 103 retweeters have zero followers.

The overwhelmingly low follower counts among retweeters suggest that most amplification behavior arises from low-profile users acting collectively, rather than from a centralized set of influential nodes. This aligns with the structural investigation of how amplification backbones emerge from the behaviors of ordinary users, independent of their social reach.

现在我们把刚才提到的东西形成narrative： Follower counts 极低意味着，尽管这些 retweeters共同参与了谣言放大，但他们本身没有强大的“外部传播能力”。

因此，这些共同行为的边更多地反映的是意识形态共鸣、情感驱动或事件反应同步性，而不是实际的信息放大效能。

这个特征强化了你们网络作为一种“放大结构现象”的解释，而不是实质性影响力传播网络。

This feature does not invalidate your network analysis; it sharpens its theoretical positioning.

| 网络类型 | Follower Counts 特征的影响 |
|---------------------|---------------------------------------------------|
| **Direct Co-Retweet** | 说明这种看似密集的网络，更多体现为对热点内容的**同步响应**，而非真实的高效放大，边代表的更多是“同一时刻被动跟风”。 |
| **Quote Pathway Co-Retweet** | 强化了这类网络的**解释性社群**特征，尽管 retweeters 没有大规模的受众，但他们通过重新解读和附加立场制造局部影响。 |
| **Reply Pathway Co-Retweet** | 进一步印证了这类网络的**情绪驱动**和**局部封闭讨论**特征，这些 retweeters 可能就是在小范围争吵、表达态度，而非具备扩散能力的放大者。 |

你的分析不是关于“谣言能被放大多远”，而是关于“谁在参与放大这种行为，以及他们如何彼此构成放大结构的骨干”。

这直接支持你提出的Amplification Backbone概念，强调的是一种社会结构现象，而非流量影响力的传递。 This feature does not invalidate your network analysis; it sharpens its theoretical positioning.

Amplifier ≠ Influencer

Literature 中“Amplifiers”的角色常常和 Influencers 混淆，但你的研究强调的是结构性放大者，他们通过共同行为增强特定叙事的可见性和存在感，而不是直接拥有巨大的传播半径。

你现在的发现正好作为一个理论修正点：“Unlike traditional studies that focus on individual influence and follower reach, this study reconceptualizes amplifiers as structural agents whose behavioral convergence sustains misinformation visibility, regardless of their personal audience size.”

这强化了 Amplification Backbone 的概念

你的网络强调的是放大者之间的结构性共鸣和联合行为模式。这种放大不一定导致广泛的外部扩散，但却维持了谣言的持续性存在和集体认知效应。

在 Literature Review 中可以明确指出：这种放大骨干的存在，正是为什么即便没有大规模的扩散，一些谣言仍然在特定群体中“长尾式存活”并反复被激活的原因。

## Graph

### Co-retweet Net

#### Stage 1 Plot (Co-retweet Net)

```{r}
#| output: false
# Load Data and Build Full Network
adj_matrix <- read.csv("data/adj_matrix_co_retweet.csv", row.names = 1, check.names = FALSE)

net_full <- network(as.matrix(adj_matrix), directed = FALSE, matrix.type = "adjacency")

retweeter_stage <- covid_wuhan_misinfo |>
  mutate(retweeter_id = as.character(retweeter_id)) |>
  select(retweeter_id, date, keywords) |>
  distinct() |>
  arrange(date) |>
  mutate(
    group = as.numeric(factor(paste(date, keywords), levels = unique(paste(date, keywords))))
  ) |>
  select(retweeter_id, group, date, keywords)

node_names <- net_full %v% "vertex.names"

assigned_groups <- retweeter_stage$group[match(node_names, retweeter_stage$retweeter_id)]

set.vertex.attribute(net_full, "group", assigned_groups)

# Assign Current Stage Info
target_group <- 1  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)

stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
edgelist <- as.edgelist(net_full)
v1 <- edgelist[, 1]
v2 <- edgelist[, 2]

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage Adjacency Matrix
adj_stage1 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage1) <- colnames(adj_stage1) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage1[v1[idx], v2[idx]] <- 1
    adj_stage1[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 1 Adjacency Matrix
write.csv(adj_stage1, "data/adj_matrix_stage1.csv", row.names = TRUE)

# Build Network Object for Stage 1
net_stage1 <- network(adj_stage1, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)

plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage1, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG
# png("plot/co_retweet_net/Co-Retweet-Stage1.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage1,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 1 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)
```

#### Stage 2 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 2  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 2 Adjacency Matrix
adj_stage2 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage2) <- colnames(adj_stage2) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage2[v1[idx], v2[idx]] <- 1
    adj_stage2[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 2 Adjacency Matrix
write.csv(adj_stage2, "data/adj_matrix_stage2.csv", row.names = TRUE)

# Build Network Object for Stage 2
net_stage2 <- network(adj_stage2, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage2, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG for Stage 2
# png("plot/co_retweet_net/Co-Retweet-Stage2.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage2,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 2 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 3 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 3  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 3 Adjacency Matrix
adj_stage3 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage3) <- colnames(adj_stage3) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage3[v1[idx], v2[idx]] <- 1
    adj_stage3[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 3 Adjacency Matrix
write.csv(adj_stage3, "data/adj_matrix_stage3.csv", row.names = TRUE)

# Build Network Object for Stage 3
net_stage3 <- network(adj_stage3, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage3, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG for Stage 3
# png("plot/co_retweet_net/Co-Retweet-Stage3.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage3,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 3 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)
```

#### Stage 4 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 4  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 4 Adjacency Matrix
adj_stage4 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage4) <- colnames(adj_stage4) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage4[v1[idx], v2[idx]] <- 1
    adj_stage4[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 4 Adjacency Matrix
write.csv(adj_stage4, "data/adj_matrix_stage4.csv", row.names = TRUE)

# Build Network Object for Stage 4
net_stage4 <- network(adj_stage4, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage4, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG for Stage 4
# png("plot/co_retweet_net/Co-Retweet-Stage4.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage4,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 4 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 5 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 5  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 5 Adjacency Matrix
adj_stage5 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage5) <- colnames(adj_stage5) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage5[v1[idx], v2[idx]] <- 1
    adj_stage5[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 5 Adjacency Matrix
write.csv(adj_stage5, "data/adj_matrix_stage5.csv", row.names = TRUE)

# Build Network Object for Stage 5
net_stage5 <- network(adj_stage5, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage5, 
  gmode = "graph", 
  mode = "kamadakawai"
)

```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG for Stage 5
# png("plot/co_retweet_net/Co-Retweet-Stage5.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage5,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 5 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 6 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 6  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

adj_stage6 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage6) <- colnames(adj_stage6) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage6[v1[idx], v2[idx]] <- 1
    adj_stage6[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage6, "data/adj_matrix_stage6.csv", row.names = TRUE)

net_stage6 <- network(adj_stage6, directed = FALSE, matrix.type = "adjacency")

plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage6, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# png("plot/co_retweet_net/Co-Retweet-Stage6.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage6,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

legend(
  "right",
  legend = c("Stage 6 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

### Quote path Co-retweet Net

#### Stage 1 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Load Adjacency Matrix for Quote Path Co-Retweet
adj_matrix_quote <- read.csv("data/adj_matrix_co_retweet_quote_path.csv", row.names = 1, check.names = FALSE)
net_full_quote <- network(as.matrix(adj_matrix_quote), directed = FALSE, matrix.type = "adjacency")

# Retweeter Stage Information (Assuming covid_wuhan_misinfo is already loaded)
node_names <- net_full_quote %v% "vertex.names"
assigned_groups <- retweeter_stage$group[match(node_names, retweeter_stage$retweeter_id)]
set.vertex.attribute(net_full_quote, "group", assigned_groups)

# Stage 1 Info
target_group <- 1
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Current Stage
edgelist <- as.edgelist(net_full_quote)
v1 <- edgelist[, 1]
v2 <- edgelist[, 2]
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 1 Adjacency Matrix
adj_stage1_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage1_quote) <- colnames(adj_stage1_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage1_quote[v1[idx], v2[idx]] <- 1
    adj_stage1_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage1_quote, "data/adj_matrix_stage1_quote.csv", row.names = TRUE)

# Build Network Object
net_stage1_quote <- network(adj_stage1_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 1"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(net_stage1_quote, 
                       gmode = "graph", 
                       mode = "kamadakawai")
```

```{r}

vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Plot and Save Image
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage1.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage1_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")

# Add Data Source Footer
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

# Add Legend
legend(
  "right",
  legend = c("Stage 1 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 2 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 2 Parameters
target_group <- 2
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 2
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 2 Adjacency Matrix
adj_stage2_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage2_quote) <- colnames(adj_stage2_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage2_quote[v1[idx], v2[idx]] <- 1
    adj_stage2_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage2_quote, "data/adj_matrix_stage2_quote.csv", row.names = TRUE)

# Build Network Object
net_stage2_quote <- network(adj_stage2_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 2"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage2_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage2.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage2_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

# Add Subtitle
mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")

# Add Data Source Footer
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

# Add Legend
legend(
  "right",
  legend = c("Stage 2 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 3 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 3 Parameters
target_group <- 3
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 3
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 3 Adjacency Matrix
adj_stage3_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage3_quote) <- colnames(adj_stage3_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage3_quote[v1[idx], v2[idx]] <- 1
    adj_stage3_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage3_quote, "data/adj_matrix_stage3_quote.csv", row.names = TRUE)

# Build Network Object
net_stage3_quote <- network(adj_stage3_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 3"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage3_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage3.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage3_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

# Add Subtitle
mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")

# Add Data Source Footer
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

# Add Legend
legend(
  "right",
  legend = c("Stage 3 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)


```

#### Stage 4 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 4 Parameters
target_group <- 4
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 4
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 4 Adjacency Matrix
adj_stage4_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage4_quote) <- colnames(adj_stage4_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage4_quote[v1[idx], v2[idx]] <- 1
    adj_stage4_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage4_quote, "data/adj_matrix_stage4_quote.csv", row.names = TRUE)

# Build Network Object
net_stage4_quote <- network(adj_stage4_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 4"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage4_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage4.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage4_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

# Add Subtitle
mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")

# Add Data Source Footer
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

# Add Legend
legend(
  "right",
  legend = c("Stage 4 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

dev.off()

```

#### Stage 5 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 5 Parameters
target_group <- 5
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 5
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 5 Adjacency Matrix
adj_stage5_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage5_quote) <- colnames(adj_stage5_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage5_quote[v1[idx], v2[idx]] <- 1
    adj_stage5_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage5_quote, "data/adj_matrix_stage5_quote.csv", row.names = TRUE)

# Build Network Object
net_stage5_quote <- network(adj_stage5_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 5"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage5_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage5.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage5_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 5 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6, 
  text.col = "black", 
  bty = "n", 
  y.intersp = 1.5
)

```

#### Stage 6 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 6 Parameters
target_group <- 6
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 6
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 6 Adjacency Matrix
adj_stage6_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage6_quote) <- colnames(adj_stage6_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage6_quote[v1[idx], v2[idx]] <- 1
    adj_stage6_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage6_quote, "data/adj_matrix_stage6_quote.csv", row.names = TRUE)

# Build Network Object
net_stage6_quote <- network(adj_stage6_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 6"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage6_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage6.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage6_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 6 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6, 
  text.col = "black", 
  bty = "n", 
  y.intersp = 1.5
)

```

### Reply path Co-retweet Net

#### Stage 1 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
# Load Data
adj_matrix_reply <- read.csv("data/adj_matrix_co_retweet_reply_path.csv", row.names = 1, check.names = FALSE)
net_full_reply <- network(as.matrix(adj_matrix_reply), directed = FALSE, matrix.type = "adjacency")

node_names <- net_full_reply %v% "vertex.names"
assigned_groups <- retweeter_stage$group[match(node_names, retweeter_stage$retweeter_id)]
set.vertex.attribute(net_full_reply, "group", assigned_groups)

# Stage 1 Settings
target_group <- 1
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Edges Filtering
edgelist_reply <- as.edgelist(net_full_reply)
v1 <- edgelist_reply[, 1]
v2 <- edgelist_reply[, 2]
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Adjacency Matrix for Stage 1
adj_stage1_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage1_reply) <- colnames(adj_stage1_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage1_reply[v1[idx], v2[idx]] <- 1
    adj_stage1_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage1_reply, "data/adj_matrix_stage1_reply.csv", row.names = TRUE)
net_stage1_reply <- network(adj_stage1_reply, directed = FALSE, matrix.type = "adjacency")

# Visualization
plot_title <- "Reply Path Co-Retweet Network: Stage 1"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)
set.seed(42)
layout_coords <- gplot(net_stage1_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# Save PNG
# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage1.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage1_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 1 Retweeters", "Other Retweeters"), 
  col = c("forestgreen", "gray"), 
  pch = 19, pt.cex = 1, cex = 0.6, 
  text.col = "black", bty = "n", y.intersp = 1.5
)

```

#### Stage 2 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
# Stage 2 Parameters
target_group <- 2
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 2
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 2 Adjacency Matrix
adj_stage2_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage2_reply) <- colnames(adj_stage2_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage2_reply[v1[idx], v2[idx]] <- 1
    adj_stage2_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage2_reply, "data/adj_matrix_stage2_reply.csv", row.names = TRUE)

# Build Network Object
net_stage2_reply <- network(adj_stage2_reply, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Reply Path Co-Retweet Network: Stage 2"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage2_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# Save PNG
# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage2.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage2_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 2 Retweeters", "Other Retweeters"), 
  col = c("forestgreen", "gray"), 
  pch = 19, pt.cex = 1, cex = 0.6, 
  text.col = "black", bty = "n", y.intersp = 1.5
)

```

#### Stage 3 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
# Stage 3 Parameters
target_group <- 3
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 3
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 3 Adjacency Matrix
adj_stage3_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage3_reply) <- colnames(adj_stage3_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage3_reply[v1[idx], v2[idx]] <- 1
    adj_stage3_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage3_reply, "data/adj_matrix_stage3_reply.csv", row.names = TRUE)

# Build Network Object
net_stage3_reply <- network(adj_stage3_reply, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Reply Path Co-Retweet Network: Stage 3"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage3_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# Save PNG
# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage3.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage3_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 3 Retweeters", "Other Retweeters"), 
  col = c("forestgreen", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5
)
```

#### Stage 4 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
target_group <- 4
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

adj_stage4_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage4_reply) <- colnames(adj_stage4_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage4_reply[v1[idx], v2[idx]] <- 1
    adj_stage4_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage4_reply, "data/adj_matrix_stage4_reply.csv", row.names = TRUE)
net_stage4_reply <- network(adj_stage4_reply, directed = FALSE, matrix.type = "adjacency")

plot_title <- "Reply Path Co-Retweet Network: Stage 4"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage4_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage4.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage4_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 4 Retweeters", "Other Retweeters"), 
  col = c("forestgreen", "gray"), 
  pch = 19, pt.cex = 1, cex = 0.6, 
  text.col = "black", bty = "n", y.intersp = 1.5
)


```

#### Stage 5 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
target_group <- 5
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

adj_stage5_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage5_reply) <- colnames(adj_stage5_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage5_reply[v1[idx], v2[idx]] <- 1
    adj_stage5_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage5_reply, "data/adj_matrix_stage5_reply.csv", row.names = TRUE)
net_stage5_reply <- network(adj_stage5_reply, directed = FALSE, matrix.type = "adjacency")

plot_title <- "Reply Path Co-Retweet Network: Stage 5"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage5_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage5.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage5_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)",
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 5 Retweeters", "Other Retweeters"),
  col = c("forestgreen", "gray"),
  pch = 19, pt.cex = 1, cex = 0.6,
  text.col = "black", bty = "n", y.intersp = 1.5
)

```

#### Stage 6 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
target_group <- 6
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

adj_stage6_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage6_reply) <- colnames(adj_stage6_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage6_reply[v1[idx], v2[idx]] <- 1
    adj_stage6_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage6_reply, "data/adj_matrix_stage6_reply.csv", row.names = TRUE)
net_stage6_reply <- network(adj_stage6_reply, directed = FALSE, matrix.type = "adjacency")

plot_title <- "Reply Path Co-Retweet Network: Stage 6"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage6_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage6.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage6_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)",
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 6 Retweeters", "Other Retweeters"),
  col = c("forestgreen", "gray"),
  pch = 19, pt.cex = 1, cex = 0.6,
  text.col = "black", bty = "n", y.intersp = 1.5
)
```

## Data Analysis

**Hi, Professor! I'm still adjusting this part. As I found my network's definition not clear, I need to reconstruct them and find proper research hypotheses. I'll adjust this part later until I totally finish the literature work. Thank you for understanding!**

```{r}
calculate_metrics_statnet <- function(csv_path, network_type, stage) {
  adj_matrix <- as.matrix(read.csv(csv_path, row.names = 1))
  net <- network(adj_matrix, directed = FALSE, matrix.type = "adjacency")
  
  if (network.size(net) <= 1) {
    return(data.frame(
      Network_Type = network_type,
      Stage = stage,
      Size = NA,
      Edges = NA,
      Density = NA,
      Avg_Degree = NA,
      Components = NA,
      Transitivity = NA,
      Isolates = NA,
      Diameter = NA,
      Average_Path_Length = NA,
      Degree_Centralization = NA,
      Betweenness_Centralization = NA,
      Closeness_Centralization = NA,
      Cliques_Total = NA,
      Cliques_Max_Size = NA,
      Cliques_Min_Size = NA
    ))
  }
  
  size <- network.size(net)
  edges <- network.edgecount(net)
  
  # Density and Average Degree
  density_val <- gden(net)
  avg_degree_val <- mean(degree(net))
  
  # Components: Exclude isolates
  components_info <- component.dist(net)
  num_components <- sum(components_info$csize > 1)
  
  isolates_count <- sum(degree(net) == 0)
  
  # Diameter
  dist_matrix <- geodist(net)$gdist
  dist_matrix[is.infinite(dist_matrix)] <- NA
  diameter_val <- max(dist_matrix, na.rm = TRUE)
  
  # Calculate Average Path Length
  avg_path_length <- mean(dist_matrix, na.rm = TRUE)
  
  # Transitivity
  transitivity_val <- gtrans(net)
  
  # Degree Centralization
  deg_vals <- degree(net)
  centralization_deg <- if (length(deg_vals) > 0) {
    (max(deg_vals) * (size - 1) - sum(max(deg_vals) - deg_vals)) / ((size - 1)^2)
  } else {
    NA
  }
  
  # Betweenness Centralization
  btw_vals <- betweenness(net)
  centralization_btw <- if (length(btw_vals) > 0) {
    (max(btw_vals) * (size - 1) - sum(max(btw_vals) - btw_vals)) / ((size - 1)^2)
  } else {
    NA
  }
  
  # Closeness Centralization
  cls_vals <- closeness(net, g = geodist(net)$gdist)
  centralization_cls <- if (length(cls_vals) > 0) {
    (max(cls_vals) * (size - 1) - sum(max(cls_vals) - cls_vals)) / ((size - 1)^2)
  } else {
    NA
  }
  
  # Clique Metrics - Filter cliques of size >= 3
  clique_info <- sna::clique.census(net, mode = "graph", tabulate.by.vertex = FALSE)
  clique_counts <- clique_info$clique.count
  valid_sizes <- which(as.numeric(names(clique_counts)) >= 3 & clique_counts > 0)
  
  total_cliques <- if (length(valid_sizes) > 0) sum(clique_counts[valid_sizes]) else 0
  max_clique_size <- if (length(valid_sizes) > 0) max(valid_sizes) else NA
  min_clique_size <- if (length(valid_sizes) > 0) min(valid_sizes) else NA

  # Output Data Frame
  data.frame(
    Network_Type = network_type,
    Stage = stage,
    Size = size,
    Edges = edges,
    Density = round(density_val, 4),
    Avg_Degree = round(avg_degree_val, 2),
    Components = num_components,
    Transitivity = round(transitivity_val, 4),
    Isolates = isolates_count,
    
    Diameter = diameter_val,
    Average_Path_Length = round(avg_path_length, 4),
    
    Degree_Centralization = round(centralization_deg, 4),
    Betweenness_Centralization = round(centralization_btw, 4),
    Closeness_Centralization = round(centralization_cls, 4),
    
    Cliques_Total = total_cliques,
    Cliques_Max_Size = max_clique_size,
    Cliques_Min_Size = min_clique_size
  )
}
```

```{r}
# Define file paths and labels
network_files <- expand.grid(
  type = c("co_retweet", "quote", "reply"),
  stage = 1:6
) %>%
  mutate(
    file_path = paste0("data/adj_matrix_stage", stage, 
                       ifelse(type == "co_retweet", "", paste0("_", type)), ".csv"),
    network_label = case_when(
      type == "co_retweet" ~ "Co-Retweet",
      type == "quote" ~ "Quote Path Co-Retweet",
      type == "reply" ~ "Reply Path Co-Retweet"
    )
  )

# Compute all metrics
all_metrics <- purrr::pmap_dfr(
  list(network_files$file_path, network_files$network_label, network_files$stage),
  calculate_metrics_statnet
)

# Final Table View
print(all_metrics)

# Save Results to CSV
write.csv(all_metrics, "data/network_metrics_summary.csv", row.names = FALSE)

```

### Data Summary in Tables

| Network_Type | Stage | Size | Edges | Density | Avg_Degree | Components | Diameter | Transitivity | Isolates |
|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
| Co-Retweet | 1 | 112 | 253 | 0.0407 | 9.04 | 1 | 1 | 1.000 | 89 |
| Quote Path Co-Retweet | 1 | 112 | 0 | 0.0000 | 0.00 | 0 | 0 | 1.000 | 112 |
| Reply Path Co-Retweet | 1 | 112 | 0 | 0.0000 | 0.00 | 0 | 0 | 1.000 | 112 |
| Co-Retweet | 2 | 112 | 420 | 0.0676 | 15.00 | 2 | 1 | 1.000 | 71 |
| Quote Path Co-Retweet | 2 | 112 | 420 | 0.0676 | 15.00 | 2 | 1 | 1.000 | 71 |
| Reply Path Co-Retweet | 2 | 112 | 420 | 0.0676 | 15.00 | 2 | 1 | 1.000 | 71 |
| Co-Retweet | 3 | 112 | 28 | 0.0045 | 1.00 | 1 | 1 | 1.000 | 104 |
| Quote Path Co-Retweet | 3 | 112 | 28 | 0.0045 | 1.00 | 1 | 1 | 1.000 | 104 |
| Reply Path Co-Retweet | 3 | 112 | 28 | 0.0045 | 1.00 | 1 | 1 | 1.000 | 104 |
| Co-Retweet | 4 | 112 | 77 | 0.0124 | 2.75 | 4 | 1 | 1.000 | 86 |
| Quote Path Co-Retweet | 4 | 112 | 57 | 0.0092 | 2.04 | 2 | 1 | 1.000 | 96 |
| Reply Path Co-Retweet | 4 | 112 | 77 | 0.0124 | 2.75 | 4 | 1 | 1.000 | 86 |
| Co-Retweet | 5 | 112 | 26 | 0.0042 | 0.93 | 1 | 2 | 0.854 | 103 |
| Quote Path Co-Retweet | 5 | 112 | 6 | 0.0010 | 0.21 | 1 | 1 | 1.000 | 108 |
| Reply Path Co-Retweet | 5 | 112 | 21 | 0.0034 | 0.75 | 1 | 1 | 1.000 | 105 |
| Co-Retweet | 6 | 112 | 10 | 0.0016 | 0.36 | 1 | 1 | 1.000 | 107 |
| Quote Path Co-Retweet | 6 | 112 | 10 | 0.0016 | 0.36 | 1 | 1 | 1.000 | 107 |
| Reply Path Co-Retweet | 6 | 112 | 10 | 0.0016 | 0.36 | 1 | 1 | 1.000 | 107 |

**Table 1: Basic Network Structure Over Time**

| Network_Type | Stage | Degree_Centralization | Betweenness_Centralization | Closeness_Centralization |
|---------------|---------------|---------------|---------------|---------------|
| Co-Retweet | 1 | 0.0786 | 0.0000 | 0 |
| Quote Path Co-Retweet | 1 | 0.0000 | 0.0000 | 0 |
| Reply Path Co-Retweet | 1 | 0.0000 | 0.0000 | 0 |
| Co-Retweet | 2 | 0.1325 | 0.0000 | 0 |
| Quote Path Co-Retweet | 2 | 0.1325 | 0.0000 | 0 |
| Reply Path Co-Retweet | 2 | 0.1325 | 0.0000 | 0 |
| Co-Retweet | 3 | 0.0080 | 0.0000 | 0 |
| Quote Path Co-Retweet | 3 | 0.0080 | 0.0000 | 0 |
| Reply Path Co-Retweet | 3 | 0.0080 | 0.0000 | 0 |
| Co-Retweet | 4 | 0.0237 | 0.0000 | 0 |
| Quote Path Co-Retweet | 4 | 0.0172 | 0.0000 | 0 |
| Reply Path Co-Retweet | 4 | 0.0237 | 0.0000 | 0 |
| Co-Retweet | 5 | 0.0071 | 0.0008 | 0 |
| Quote Path Co-Retweet | 5 | 0.0015 | 0.0000 | 0 |
| Reply Path Co-Retweet | 5 | 0.0058 | 0.0000 | 0 |
| Co-Retweet | 6 | 0.0026 | 0.0000 | 0 |
| Quote Path Co-Retweet | 6 | 0.0026 | 0.0000 | 0 |
| Reply Path Co-Retweet | 6 | 0.0026 | 0.0000 | 0 |

**Table 2: Network Centralization Over Time**

| Network_Type          | Stage | Cliques_Total | Cliques_Max_Size | Cliques_Min_Size |
|---------------|---------------|---------------|---------------|---------------|
| Co-Retweet            | 1     | 1             | 23               | 23               |
| Quote Path Co-Retweet | 1     | 0             | NA               | NA               |
| Reply Path Co-Retweet | 1     | 0             | NA               | NA               |
| Co-Retweet            | 2     | 2             | 25               | 16               |
| Quote Path Co-Retweet | 2     | 2             | 25               | 16               |
| Reply Path Co-Retweet | 2     | 2             | 25               | 16               |
| Co-Retweet            | 3     | 1             | 8                | 8                |
| Quote Path Co-Retweet | 3     | 1             | 8                | 8                |
| Reply Path Co-Retweet | 3     | 1             | 8                | 8                |
| Co-Retweet            | 4     | 4             | 9                | 5                |
| Quote Path Co-Retweet | 4     | 2             | 9                | 7                |
| Reply Path Co-Retweet | 4     | 4             | 9                | 5                |
| Co-Retweet            | 5     | 2             | 7                | 4                |
| Quote Path Co-Retweet | 5     | 1             | 4                | 4                |
| Reply Path Co-Retweet | 5     | 1             | 7                | 7                |
| Co-Retweet            | 6     | 1             | 5                | 5                |
| Quote Path Co-Retweet | 6     | 1             | 5                | 5                |
| Reply Path Co-Retweet | 6     | 1             | 5                | 5                |

**Table 3: Clique Structural Features Over Time**

### Univariate Analysis and Visualization

Table 1 (Network Density Over Time included) and Table 2 (Degree Centralization Over Time included) display the temporal variations in network density and degree centralization across different types of retweeter amplification backbones. These visualizations provide initial insights into the structural dynamics of misinformation diffusion.

### Expected & actual findings based on hypotheses

四个假设与 CUG、ERGM 检验的对应关系 Hypothesis 指标 CUG Test ERGM 可以得出的结论 H1: Density & Avg Degree Density, Avg Degree ❌（描述性即可） ❌ 不适合 CUG/ERGM，用 ANOVA/描述统计验证 H2: Degree Centralization Degree Centralization ✅ ✅ 核心节点是否显著集中 H3: Clustering Coefficient Transitivity (Clustering) ✅ ✅ (gwesp term) 网络中三元闭合（群体化）倾向 H4: Temporal Variation Degree Centralization, Density ✅ ❌ 不同时间点的中心化和密度是否递减

#### H1 (Density and Average Degree): Direct co-retweet networks will exhibit the highest density and average degree among the three networks.

**Null Hypothesis (H0):** The mean density and average degree are the same across the three network types.

Descriptive trends indicated that direct co-retweet networks generally exhibited higher density and average degree compared to quote path and reply path co-retweet networks. For instance, in Stage 2, the density for co-retweet networks was 0.0676 with an average degree of 15.00, while both quote and reply path networks showed identical but lower values. This pattern was consistently observed across later stages.

A one-way ANOVA was conducted to assess whether these observed differences were statistically significant.

```{r}
#| output: false

# One-Way ANOVA for Density
anova_density <- aov(Density ~ Network_Type, data = all_metrics)
summary(anova_density)
TukeyHSD(anova_density)

# One-Way ANOVA for Average Degree
anova_degree <- aov(Avg_Degree ~ Network_Type, data = all_metrics)
summary(anova_degree)
TukeyHSD(anova_degree)


# Calculate Means and Standard Deviations
density_stats <- all_metrics %>% 
  group_by(Network_Type) %>% 
  summarise(Mean_Density = round(mean(Density, na.rm = TRUE), 4),
            SD_Density = round(sd(Density, na.rm = TRUE), 4))

degree_stats <- all_metrics %>% 
  group_by(Network_Type) %>% 
  summarise(Mean_Avg_Degree = round(mean(Avg_Degree, na.rm = TRUE), 2),
            SD_Avg_Degree = round(sd(Avg_Degree, na.rm = TRUE), 2))

# Calculate Effect Sizes (η²)
eta_density <- eta_squared(anova_density)
eta_degree <- eta_squared(anova_degree)

```

The ANOVA results revealed no statistically significant differences in density, F(2, 15) = 0.158, p = .855, nor in average degree, F(2, 15) = 0.158, p = .855. Post-hoc comparisons using Tukey’s HSD test further confirmed that none of the pairwise differences between network types were statistically significant (p \> .85 for all comparisons).

**Descriptive Statistics for Density:**

| Network Type          | Mean Density | SD Density |
|-----------------------|--------------|------------|
| Co-Retweet            | 0.0218       | 0.0267     |
| Quote Path Co-Retweet | 0.0140       | 0.0265     |
| Reply Path Co-Retweet | 0.0149       | 0.0262     |

**Descriptive Statistics for Average Degree:**

| Network Type          | Mean Avg Degree | SD Avg Degree |
|-----------------------|-----------------|---------------|
| Co-Retweet            | 4.85            | 5.92          |
| Quote Path Co-Retweet | 3.10            | 5.88          |
| Reply Path Co-Retweet | 3.31            | 5.81          |

**Post-hoc Test Results for Density:**

| Comparison           | Difference | 95% CI Lower | 95% CI Upper | p-value |
|----------------------|------------|--------------|--------------|---------|
| Quote vs. Co-Retweet | -0.0079    | -0.0475      | 0.0318       | .866    |
| Reply vs. Co-Retweet | -0.0069    | -0.0466      | 0.0327       | .894    |
| Reply vs. Quote      | 0.0009     | -0.0387      | 0.0406       | .998    |

**Post-hoc Test Results for Average Degree:**

| Comparison           | Difference | 95% CI Lower | 95% CI Upper | p-value |
|----------------------|------------|--------------|--------------|---------|
| Quote vs. Co-Retweet | -1.745     | -10.545      | 7.055        | .865    |
| Reply vs. Co-Retweet | -1.537     | -10.336      | 7.263        | .894    |
| Reply vs. Quote      | 0.208      | -8.591       | 9.008        | .998    |

**Effect Sizes (η²):**

| Metric         | η² Effect Size |
|----------------|----------------|
| Density        | 0.02           |
| Average Degree | 0.02           |

Based on these results, we failed to reject the null hypothesis. While descriptive patterns suggest higher density and average degree in direct co-retweet networks, these differences were not statistically significant. Therefore, H1 is not supported by the current data.

#### H2 (Degree Centralization): Reply pathway co-retweet networks will exhibit the highest degree centralization, followed by quote pathway networks, with direct co-retweet networks exhibiting the lowest.

Null Hypothesis (H0): The mean degree centralization has no difference across the three network types.

Descriptive observations suggest that, contrary to expectations, direct co-retweet networks often show higher or equivalent degree centralization. For instance, in Stage 2, all three network types exhibit identical degree centralization values (0.1325). In later stages, direct co-retweet networks consistently demonstrate slightly higher degree centralization compared to quote and reply pathway networks.

To formally test whether the observed degree centralization values significantly deviate from random network structures, CUG tests were performed. Additionally, Exponential Random Graph Models (ERGMs) were estimated to explore structural factors contributing to centralization.

Findings: Contrary to expectations, direct co-retweet networks often show higher or equivalent degree centralization. For instance, in Stage 2, all three network types exhibit the same degree centralization (0.1325), but in later stages, co-retweet networks slightly outperform the others.

Conclusion: H2 is not supported. The expected hierarchical dominance in reply networks is not observed, indicating that influential retweeters are not more structurally central in reply-based interactions compared to direct co-retweet behaviors.

#### H3 (Clustering Coefficient)

Quote pathway co-retweet networks will exhibit the highest clustering coefficient, followed by reply pathway networks, with direct co-retweet networks exhibiting the lowest.

Findings: Clustering coefficients remain consistently high (often 1.000) across all network types and stages, with only slight variations (e.g., Stage 5 shows a lower clustering coefficient of 0.854 for co-retweet networks). This uniformity suggests that triadic closures are prevalent across all forms of engagement and are not significantly differentiated by retweeting behavior.

Conclusion: H3 is partially supported. While quote networks sometimes exhibit higher clustering (e.g., fewer isolates), the differences are marginal and not consistently observed across all stages.

#### H4 (Temporal Variation)

Retweeter amplification backbone networks formed during earlier misinformation events will demonstrate higher density and degree centralization than those formed during later events.

Findings: Early stages (Stages 1 and 2) show notably higher density and degree centralization across all network types. For example, density for co-retweet networks is 0.0676 in Stage 2 but declines steadily in later stages, reaching as low as 0.0016 by Stage 6. Degree centralization follows a similar pattern.

Conclusion: H4 is strongly supported, indicating that misinformation amplification structures tend to be more active and centralized during the early emergence of misinformation events but become fragmented over time.

#### Statistical Significance and Goodness of Fit

Although statistical tests such as t-tests and CUG models were planned, the current dataset suggests clear trends without needing additional inferential testing for basic structural metrics. The observed differences align with theoretical expectations in H1 and H4 but contradict H2 and only partially support H3. The goodness of fit for network models would require ERGM or other advanced modeling techniques, which are beyond the current exploratory analysis scope.

#### CUG

```{r}
# read_network <- function(file_path) {
#   adj_matrix <- as.matrix(read.csv(file_path, row.names = 1))
#   net <- network(adj_matrix, directed = FALSE, matrix.type = "adjacency")
#   return(net)
# }
# 
# run_cug_tests <- function(file_path, network_label, stage) {
#   net <- read_network(file_path)
#   
#   if (network.size(net) <= 1 || network.edgecount(net) == 0) {
#     return(data.frame(
#       Network_Type = network_label,
#       Stage = stage,
#       Degree_Centralization = NA,
#       Degree_p = NA,
#       Transitivity = NA,
#       Transitivity_p = NA
#     ))
#   }
#   
#   # Safe CUG Degree Centralization
#   cug_deg <- tryCatch({
#     cug.test(
#       net, 
#       function(x) centralization(x, degree, mode = "graph"), 
#       cmode = "edges", 
#       reps = 1000
#     )
#   }, error = function(e) NULL)
#   
#   # Safe CUG Transitivity
#   cug_trans <- tryCatch({
#     cug.test(
#       net, 
#       gtrans, 
#       cmode = "edges", 
#       reps = 1000
#     )
#   }, error = function(e) NULL)
#   
#   data.frame(
#     Network_Type = network_label,
#     Stage = stage,
#     Degree_Centralization = if (!is.null(cug_deg)) cug_deg$obs.stat else NA,
#     Degree_p = if (!is.null(cug_deg)) cug_deg$pval else NA,
#     Transitivity = if (!is.null(cug_trans)) cug_trans$obs.stat else NA,
#     Transitivity_p = if (!is.null(cug_trans)) cug_trans$pval else NA
#   )
# }
# 
# 
# # calculate CUG
# cug_results <- pmap_dfr(
#   list(network_files$file_path, network_files$network_label, network_files$stage),
#   run_cug_tests
# )
# 
# # print results
# print(cug_results)
# write.csv(cug_results, "data/cug_results_summary.csv", row.names = FALSE)
# 
# ??sna::centralization.degree
# 
# net <- read_network("data/adj_matrix_stage1.csv")
# print(net)
# summary(net)
# 
# 
# cug_deg <- tryCatch({
#   cug.test(
#     net, 
#     function(x) centralization(x, degree, mode = "graph"), 
#     cmode = "edges", 
#     reps = 100
#   )
# }, error = function(e) e)
# 
# print(cug_deg)
# 
# 
# centralization(net, degree, mode = "graph")
# 
# 
# 
# 
# set.seed(123)  # 保持可重复性
# 
# 
# observed_deg_cent <- centralization(net, degree, mode = "graph")
# 
# 
# sim_deg_cents <- replicate(1000, {
#   rand_net <- rgraph(network.size(net), tprob = network.density(net))
#   centralization(rand_net, degree, mode = "graph")
# })
# 
# 
# p_value_deg <- mean(sim_deg_cents >= observed_deg_cent)
# 
# 
# cat("Observed Degree Centralization:", round(observed_deg_cent, 4), "\n")
# cat("Empirical p-value:", round(p_value_deg, 4), "\n")
# 
# 
# ```
# 
# ```{r}
# run_manual_cug <- function(file_path, network_label, stage, reps = 1000) {
#   net <- read_network(file_path)
#   
#   if (network.size(net) <= 1 || network.edgecount(net) == 0) {
#     return(data.frame(
#       Network_Type = network_label,
#       Stage = stage,
#       Degree_Centralization = NA,
#       Degree_p = NA,
#       Transitivity = NA,
#       Transitivity_p = NA
#     ))
#   }
#   
#   set.seed(123)  
#   
#   # 1. Degree Centralization CUG
#   observed_deg_cent <- centralization(net, degree, mode = "graph")
#   sim_deg_cents <- replicate(reps, {
#     rand_net <- rgraph(network.size(net), tprob = network.density(net))
#     centralization(rand_net, degree, mode = "graph")
#   })
#   p_value_deg <- mean(sim_deg_cents >= observed_deg_cent)
#   
#   # 2. Transitivity (Clustering Coefficient) CUG
#   observed_trans <- gtrans(net)
#   sim_trans_vals <- replicate(reps, {
#     rand_net <- rgraph(network.size(net), tprob = network.density(net))
#     gtrans(rand_net)
#   })
#   p_value_trans <- mean(sim_trans_vals >= observed_trans)
#   
#   data.frame(
#     Network_Type = network_label,
#     Stage = stage,
#     Degree_Centralization = round(observed_deg_cent, 4),
#     Degree_p = round(p_value_deg, 4),
#     Transitivity = round(observed_trans, 4),
#     Transitivity_p = round(p_value_trans, 4)
#   )
# }
# 
# # 批量计算全部 18 个网络
# cug_results <- pmap_dfr(
#   list(network_files$file_path, network_files$network_label, network_files$stage),
#   run_manual_cug
# )
# 
# # 保存结果
# write.csv(cug_results, "data/cug_results_summary.csv", row.names = FALSE)
# print(cug_results)
# 
# 
# isolates_prop <- sum(degree(net) == 0) / network.size(net)
# 
# local_trans <- sna::triad.census(net)
# 
# ```
# 
# ```{r}
# network_metrics <- data.frame(
#   Network_Type = rep(c("Co-Retweet", "Quote Path", "Reply Path"), each = 6),
#   Stage = rep(1:6, times = 3),
#   Density = c(0.0407, 0.0676, 0.0045, 0.0124, 0.0042, 0.0016, 
#                0.0000, 0.0676, 0.0045, 0.0092, 0.0010, 0.0016, 
#                0.0000, 0.0676, 0.0045, 0.0124, 0.0034, 0.0016)
# )
# 
# # t-Test: Co-Retweet vs. Quote Path on Density
# t_test_result <- t.test(
#   Density ~ Network_Type, 
#   data = subset(network_metrics, Network_Type %in% c("Co-Retweet", "Quote Path"))
# )
# print(t_test_result)
# 

```

```{=html}
<script>
document.addEventListener("DOMContentLoaded", function() {
    const toc = document.getElementById("TOC");
    if (toc) {
        const sourceLink = document.createElement("div");
        sourceLink.innerHTML = `
            <div class="toc-source">
                <a href="https://github.com/troy-yu-cheng/sna-final-paper" 
                   target="_blank" 
                   class="github-button">
                   <svg xmlns="http://www.w3.org/2000/svg" 
                        viewBox="0 0 24 24" 
                        width="16" 
                        height="16" 
                        fill="currentColor"
                        style="vertical-align: middle; margin-right: 5px;">
                     <path d="M12 0C5.373 0 0 5.373 0 12c0 5.303 3.438 9.8 8.207 11.387.6.113.82-.26.82-.577v-2.157c-3.338.726-4.033-1.416-4.033-1.416-.546-1.386-1.332-1.756-1.332-1.756-1.09-.745.083-.73.083-.73 1.205.084 1.84 1.237 1.84 1.237 1.07 1.832 2.807 1.303 3.492.996.108-.774.418-1.303.76-1.602-2.665-.3-5.466-1.332-5.466-5.93 0-1.311.468-2.382 1.237-3.222-.124-.302-.536-1.52.118-3.163 0 0 1.008-.322 3.3 1.23a11.516 11.516 0 0 1 3.002-.403 11.486 11.486 0 0 1 3.002.403c2.292-1.552 3.3-1.23 3.3-1.23.654 1.644.242 2.861.118 3.163.77.84 1.236 1.911 1.236 3.222 0 4.61-2.807 5.627-5.48 5.922.43.372.812 1.103.812 2.222v3.293c0 .321.218.694.825.576C20.565 21.796 24 17.3 24 12 24 5.373 18.627 0 12 0z"/>
                   </svg>
                   View source
                </a>
            </div>
        `;
        toc.appendChild(sourceLink);
    }
});
</script>
```
