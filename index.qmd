---
title: "Social Network Analysis"
subtitle: "Temporal Patterns of Misinformation Diffusion: A Multi-Stage Network Analysis of COVID-19 Origin Narratives on Twitter"
author: 
  - name: "Troy (Yu) Cheng"
    email: yc1317@georgetown.edu
    affiliation: Georgetown University
    corresponding: true
df-print: kable
title-block-banner: "#0a0e1a"
title-block-banner-color: "#4DB8FF"
execute:
  warning: false
date: 2025-04-28
date-modified: last-modified
format:
  html:
    embed-resources: true
    toc: true                 
    toc-title: "Contents"     
    toc-location: right       
    number-sections: true
    number-depth: 3       
    smooth-scroll: true       
    css: trycstyle.css 
    code-overflow: wrap
include-in-header:
  text: |
    <link rel="shortcut icon" href="assets/gu.ico" type="image/x-icon">           
highlight-style: nord       
engine: knitr
---

------------------------------------------------------------------------

# Abstract

The amplification of misinformation on social media platforms remains a critical concern, particularly when false narratives gain widespread attention through collective user behaviors. While existing research often focuses on individual-level attributes or direct information cascades, less is known about how groups of users jointly contribute to the amplification of misinformation through co-dissemination behaviors.

This study focuses on retweeters of misinformation claims as the core agents of amplification, analyzing how different forms of shared retweeting behavior shape the structural characteristics of retweeter co-dissemination networks associated with misinformation claims. Retweeter nodes are connected through co-dissemination ties based on three distinct behaviors: (1) both retweeters retweeted the same misinformation tweet, (2) both retweeters retweeted misinformation tweet or content quoting it, and (3) both retweeters retweeted misinformation tweet or content replying to it.

By investigating the density, transitivity, and centralization of these networks, this research explores how distinct retweeter behaviors reflect patterns of collective amplification in misinformation networks. The research question guiding this analysis is: How do different co-dissemination behaviors, which are operationalized through direct, quote, and reply co-retweeting, shape the structural characteristics and potential amplification patterns of misinformation retweeter networks?

------------------------------------------------------------------------

# Introduction

The rapid amplification of misinformation on social media platforms poses significant challenges to public discourse and crisis communication. In digital environments where information flows are accelerated by algorithmic amplification and user engagement, false narratives can quickly gain traction and shape public perceptions. While previous studies have extensively examined the role of individual user characteristics and content virality in misinformation diffusion, relatively less attention has been paid to the collective behaviors of users who jointly participate in the dissemination of misinformation. Understanding how such co-dissemination behaviors shape the structural characteristics of misinformation disseminator networks is critical for unpacking the social dynamics that underlie online amplification processes.

This study centers on the role of retweeters as core agents in the collective amplification of misinformation. Unlike content originators or passive consumers, retweeters actively participate in the diffusion process, often functioning as critical conduits for message reinforcement and visibility. By focusing on retweeters, this research captures the amplification effect not at the level of individual virality, but through the lens of shared dissemination behaviors within user networks. Specifically, this study examines how retweeter co-dissemination behaviors—operationalized through three distinct retweeting patterns—shape the structural characteristics of misinformation retweeting networks.

In operationalizing these behaviors, three types of network ties are defined: (1) Direct Co-Retweet, where two retweeters have both retweeted the same misinformation tweet; (2) Quote Pathway Co-Retweet, where two retweeters have both retweeted either the original misinformation tweet or tweets quoting it; and (3) Reply Pathway Co-Retweet, where two retweeters have both retweeted either the original misinformation tweet or tweets replying to it. These distinctions capture varying levels of engagement with misinformation narratives, from direct repetition to contextual reinterpretation and interactive discussion.

Building on theories of social media engagement and the network amplification effect, this research explores whether these different co-dissemination behaviors produce distinct network structures that may reflect varying degrees of amplification potential. Twitter (now X) provides an ideal platform for this investigation due to its central role in real-time information diffusion and its unique retweet function, which facilitates rapid content propagation.

Using Social Network Analysis (SNA), this study systematically evaluates the density, transitivity, and centralization of retweeter networks formed under each dissemination behavior. Statistical comparisons, including t-tests and Conditional Uniform Graph (CUG) tests, are employed to assess the significance of observed structural differences across networks. Although node attribute data is limited, exploratory Exponential Random Graph Models (ERGMs) are used to examine whether basic structural patterns explain tie formation probabilities. Furthermore, six distinct misinformation events related to [the COVID-19 Wuhan lab origin theory](https://en.wikipedia.org/wiki/COVID-19_lab_leak_theory), spanning from March 2020 to August 2021, provide a temporal dimension for analysis. This results in a comparative framework of 18 retweeter networks (three dissemination pathways across six misinformation claims), allowing for an assessment of both structural and temporal variation in misinformation amplification dynamics.

By focusing on the collective behaviors of retweeters rather than individual-level attributes, this research advances understanding of how misinformation narratives are socially amplified through shared dissemination practices. The findings aim to contribute to broader discussions on combating misinformation by highlighting the structural pathways through which false narratives gain visibility and social reinforcement in online environments.

# Literature Review

## Misinformation Amplification on Social Media

The proliferation of misinformation on social media platforms has emerged as a significant concern, particularly during global crises such as the COVID-19 pandemic. Research indicates that false information often spreads more rapidly and extensively than factual content, driven by factors like emotional resonance and algorithmic amplification. Vosoughi, Roy, and Aral (2018) found that false news stories are 70% more likely to be retweeted than true ones, with falsehoods reaching more people and spreading faster. This phenomenon is partly attributed to the novelty and emotional appeal of misinformation, which captures users' attention and prompts sharing.

Social media platforms, notably Twitter (now X), facilitate the rapid dissemination of such content through features like retweets and likes, which can inadvertently amplify misinformation. Guess et al. (2019) observed that a small subset of users, particularly older adults, are disproportionately responsible for sharing false news on Facebook, highlighting the role of user behavior in the spread of misinformation.

Algorithmic curation further exacerbates the issue by promoting content that elicits strong emotional reactions, such as anger or fear, thereby increasing engagement metrics. Cinelli et al. (2020) demonstrated that platforms like Twitter and Facebook can create echo chambers where users are exposed predominantly to information that aligns with their existing beliefs, reinforcing misinformation. This environment not only accelerates the spread of false narratives but also hampers the dissemination of corrective information.

The COVID-19 pandemic has underscored the dangers of misinformation amplification. Cinelli et al. (2020) analyzed the diffusion of COVID-19-related information across multiple platforms and found that misinformation often spreads faster than factual content, posing significant challenges to public health efforts. The World Health Organization has termed this overabundance of information, both accurate and misleading, as an "infodemic," emphasizing the need for effective strategies to manage information dissemination during health crises.

## Retweeters as Amplifiers in Misinformation Networks

While much attention has been given to the originators of misinformation, retweeters play a crucial role in its propagation. Retweeters act as intermediaries, bridging content to broader audiences and often contributing to the virality of misinformation. Shao et al. (2018) found that a small number of accounts, often retweeters, were responsible for a significant portion of the spread of low-credibility content, highlighting their amplifying effect. Similarly, Ferrara (2020) observed that coordinated retweeting behaviors can significantly enhance the reach and impact of false narratives, underscoring the importance of analyzing retweeter networks.

The structural characteristics of retweeter networks can influence the dissemination patterns of misinformation. Guarino et al. (2020) demonstrated that misinformation networks often exhibit higher modularity and clustering coefficients compared to factual information networks, suggesting that retweeters form tightly-knit communities that facilitate rapid information spread. These structural features can create echo chambers, where misinformation is reinforced and seldom challenged.

Recent studies have also explored the temporal dynamics of retweeter behavior. Stam et al. (2024) introduced a novel metric to track the speed at which users traverse social networks, revealing that retweeters of misinformation tend to engage with homogeneous content and communities over time. This behavior contributes to the persistence and reinforcement of false narratives within specific user groups.

Furthermore, the role of retweeters in shaping public discourse has been examined in the context of specific events. For instance, during the COVID-19 pandemic, retweeters were instrumental in spreading both accurate information and misinformation. Cinelli et al. (2020) analyzed the diffusion of COVID-19-related information across multiple platforms and found that retweeters significantly influenced the reach and speed of information dissemination, often amplifying content that aligned with their beliefs.

Understanding the behaviors and network positions of retweeters is essential for developing strategies to mitigate the spread of misinformation. By identifying key retweeters and analyzing their network connections, interventions can be designed to disrupt the flow of false information and promote the dissemination of accurate content.

## Network Structures and Co-Dissemination Behaviors

Understanding the structural characteristics of misinformation diffusion networks is critical for identifying patterns of spread and potential intervention points. Social Network Analysis (SNA) provides powerful tools to examine network metrics such as density, centralization, and transitivity (Wasserman & Faust, 1994). Recent studies reveal that misinformation networks often exhibit highly centralized structures, enabling faster and broader dissemination through a few influential nodes (Guarino et al., 2020).

An increasingly important area of investigation within this field focuses on the co-dissemination behaviors of users—specifically, how retweeters collectively participate in the spread of misinformation. While early research often concentrated on the role of misinformation originators, subsequent studies have highlighted the critical amplifying function of retweeters (Ferrara, 2020; Shao et al., 2018). These actors are not merely passive intermediaries; their coordinated or patterned behaviors can significantly shape the trajectory and reach of misinformation narratives (Weber & Neumann, 2021).

Co-dissemination behaviors take various forms across social media platforms. For instance, quote retweets enable users to reinterpret or frame misinformation content within new narratives, potentially expanding its appeal and emotional resonance (Zhao & Wang, 2024). Replies, on the other hand, often introduce controversy or debate, which may paradoxically reinforce the visibility and longevity of false narratives (Wu & Shen, 2023). Studies on coordinated behavior further demonstrate that synchronized retweeting patterns, even in the absence of direct coordination, can contribute to the rapid amplification of specific claims (Truong et al., 2021).

Despite growing attention to these behaviors, much of the existing literature tends to treat retweeting as a uniform action without systematically distinguishing between the different relational pathways through which misinformation spreads. This lack of differentiation overlooks important variations in how narratives are amplified, reinterpreted, or contested across user interactions. Addressing this gap, our study builds on prior work to explore how distinguishing between co-dissemination behaviors—such as direct retweeting, quoting, and replying—can offer a more nuanced understanding of misinformation diffusion dynamics.

# Research Method

## Data Source and Collection

The data utilized in this research are derived from the [MuMiN (Multilingual Misinformation Network) dataset](https://mumin-dataset.github.io/), which comprises large-scale misinformation diffusion events on Twitter (now X) occurring between March 2020 and August 2021. Specifically, we focus on a set of six prominent misinformation claims related to the narrative asserting that [COVID-19 was deliberately created or manufactured by China or a laboratory in Wuhan](https://en.wikipedia.org/wiki/COVID-19_lab_leak_theory). Each misinformation claim represents a distinct temporal event, thus allowing for comparisons across different stages of misinformation dissemination.

## Nodes and Edges Definition

The analytical unit in this study is individual retweeters, Twitter users who actively engaged in disseminating misinformation claims by retweeting relevant content. Each retweeter is represented as a network node, and relationships (edges) between these nodes are operationalized through three distinct co-retweeting behaviors: The relationships between retweeters (edges) are defined by three distinct co-retweeting behaviors:

1.  Direct co-retweet: An edge between two retweeters is formed if both retweeted exactly the same original misinformation tweet. This represents direct, synchronous engagement and captures the immediate amplification behavior around misinformation.

2.  Quote pathway co-retweet: An edge is established between two retweeters if both retweeted either the original misinformation tweet or a tweet explicitly quoting it. This behavior includes secondary dissemination through user-generated reinterpretations, potentially broadening the narrative framing around the misinformation.

3.  Reply pathway co-retweet: An edge connects two retweeters if both retweeted either the original misinformation tweet or a tweet explicitly replying to it. This pathway highlights interactive engagement, reflecting discussions, debates, or reactions surrounding misinformation content.

Each co-retweeting behavior results in a distinct adjacency matrix, generating three separate network across six misinformation claims which represent the same topic.

## Analytical Strategy and Network Metrics

Social Network Analysis (SNA) techniques are systematically applied to evaluate structural properties of the retweeter networks constructed from each co-dissemination behavior. Specifically, this study focuses on three primary structural metrics:

1.  Network Density, which measures the proportion of actual connections to all possible connections among retweeters, indicating the overall intensity of collective dissemination.

2.  Transitivity (Global Clustering Coefficient), capturing the extent to which retweeters tend to cluster into tightly interconnected groups, reflecting localized amplification dynamics.

3.  Degree Centralization (Freeman’s Centralization), assessing the degree to which networks are structurally centralized around influential retweeters or "hubs," potentially highlighting core influencers in misinformation propagation.

## Hypotheses

Based on our research question and theoretical considerations, this study proposes the following hypotheses regarding structural differences among the three co-retweet networks:

**H1 (Density):** *Direct co-retweet networks exhibit significantly higher density and average degree compared to quote and reply pathway networks.*

This hypothesis is grounded in the assumption that direct co-retweeting, as a more explicit form of simultaneous engagement, leads to denser connections among retweeters.

**H2 (Centralization):** *Quote and reply pathway co-retweet networks exhibit significantly higher degree centralization compared to direct co-retweet networks.*

This hypothesis anticipates that retweeters engaging in secondary dissemination behaviors (quote or reply) form more centralized structures, driven by influential actors shaping the interpretation or discussion around misinformation.

**H3 (Transitivity):** *Quote pathway co-retweet networks demonstrate higher transitivity (global clustering coefficient), reflecting tighter subgroup clustering compared to direct and reply pathway networks.*

We posit that quote-based retweeting, which inherently involves reinterpretation or reframing of content, fosters greater clustering among subsets of retweeters.

**H4 (Core Node Formation):** *Reply pathway co-retweet networks are more likely to exhibit clear core-periphery structures, featuring prominent central nodes (influential retweeters), compared to direct or quote pathway networks.*

This hypothesis aligns with the interactive nature of reply-based dissemination, where debates and discussions can amplify the prominence of certain users.

**H5 (Temporal Variation):** *The structural characteristics (density, transitivity, and centralization) of co-retweet networks significantly vary across different temporal misinformation events.*

Specifically, early-stage misinformation claims are hypothesized to produce denser and more centralized retweeter networks compared to claims disseminated at later stages, reflecting early retweeters' structural advantage in amplifying misinformation narratives.

These hypotheses are systematically tested through the comparative network analyses and statistical approaches outlined in this methods section.

## Comparative Statistical Analysis

To rigorously assess the differences among the three types of co-retweet networks, statistical analyses are conducted as follows:

Firstly, descriptive statistics are computed to characterize the structural metrics (density, transitivity, and centralization) for each network type. Subsequently, pairwise t-tests and analysis of variance (ANOVA) are utilized to evaluate whether differences in structural metrics across network types are statistically significant.

To further validate the clustering patterns observed, Conditional Uniform Graph (CUG) tests are employed. CUG tests specifically determine whether the observed transitivity (clustering) within each retweeter network significantly exceeds expectations under random graph scenarios, thus confirming whether observed clustering is structurally meaningful rather than attributable to random chance.

## Temporal Comparative Analysis

Considering that the misinformation claims occurred at distinct time points, this study leverages the temporal dimension inherent in the dataset. Each misinformation claim is analyzed separately, resulting in six temporal events. Given the three co-retweet behaviors, a total of 18 sub-networks (6 misinformation events × 3 co-retweet behaviors) are analyzed.

Comparative analyses across these temporal sub-networks are conducted to identify structural variations over time. Specifically, structural metrics (density, transitivity, centralization) are compared across earlier versus later misinformation events. The goal is to explore whether earlier-stage misinformation claims form structurally distinct retweeter networks, potentially indicating differences in amplification dynamics across misinformation lifecycle stages.

## Exploratory Exponential Random Graph Models (ERGMs)

While detailed node attribute data are limited in our dataset, exploratory Exponential Random Graph Models (ERGMs) are additionally employed to understand underlying structural mechanisms influencing network formation. These ERGMs focus primarily on structural features, such as edges, degree distributions, and transitivity, to provide insights into fundamental network-generating processes driving tie formation among retweeters. Although exploratory, these models serve as valuable robustness checks that complement our descriptive and comparative findings.

## Tools

All data processing, network construction, and analysis procedures were conducted using the RStudio (version \>= 4.0.0), primarily leveraging the `statnet` family of packages for network analysis, along with auxiliary packages for statistical testing (`stats` etc.) and data visualization (`ggplot2` etc.).

# Data Collection & Graph

## Dataset

This study uses secondary data from the **MuMiN Project** (Multi-platform Misinformation Influence Network), publicly available at: <https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml/resource/e63a98c4-b4d6-4a89-9be9-06875b83ce33?inner_span=True>

The dataset includes information about social media users, tweets, misinformation claims, and their relational behaviors across various platforms.

## Data Preparation

### Loading Required Packages

```{r}
#| label: set up packages
library(tidyverse)
library(readr)
library(statnet)
library(intergraph)
library(reshape2)
library(btergm)
```

### Loading and Merging Data

```{r}
# Load data
tweets <- read_csv("data/mumin_csv/tweet.csv")
claims <- read_csv("data/mumin_csv/claim.csv")
tweet_claim <- read_csv("data/mumin_csv/tweet_discusses_claim.csv")
user_retweet <- read_csv("data/mumin_csv/user_retweeted_tweet.csv")

# Join tweet & claim via tweet_claim
tweet_claim_joined <- tweet_claim |> 
  rename(tweet_id = src, claim_id = tgt) |> 
  inner_join(claims, by = c("claim_id" = "id"))

# Join retweeters within users & claim via retweeted tweet
user_claim <- user_retweet |> 
  rename(retweeter_id = src, tweet_id = tgt) |> 
  inner_join(tweet_claim_joined, by = "tweet_id")

# Create a mapping of retweeters and tweets
retweet_map <- user_claim |> 
  select(retweeter_id, tweet_id) |> 
  distinct() 

# Basic data overview
table(user_claim$label)
head(table(user_claim$cluster_keywords))
```

### Filtering for Target Misinformation Narratives

This study focuses specifically on misinformation narratives claiming that **COVID-19 was deliberately created or spread by China or the Wuhan laboratory**. The following filtering steps were applied:

1.  Filter keywords containing "china" or "wuhan".

2.  Manually select misinformation topics directly related to the COVID-19 origin narrative.

3.  Restrict the analysis to English-language posts labeled as "misinformation".

**Note:**

```{r}
user_claim_filtered <- user_claim |> 
  filter(str_detect(keywords, "china|wuhan")) 

head(unique(user_claim_filtered$keywords))

# Final filtered dataset
covid_wuhan_misinfo <- user_claim_filtered |>
  filter(keywords %in% c(
    "coronavirus comes biological laboratory wuhan",
    "including corona virus manufactured wuhan",
    "china created spread coronavirus",
    "announced coronavirus artificially created china",
    "china created coronavirus",
    "coronavirus created laboratory china",
    "honjo said china manufactured coronavirus",
    "said new coronavirus manufactured wuhan",
    "coronavirus tested biological weapon china",
    "china testing coronavirus biological weapon",
    "covid 19 lab china",
    "coronavirus natural worked wuhan laboratory",
    "coronavirus manufactured laboratory wuhan specifically",
    "doctor claimed coronavirus china create",
    "corona virus manufactured china",
    "says current coronavirus manufactured wuhan",
    "wuhan coronavirus created patented",
    "covid 19 disease manufactured china",
    "pandemic caused artificial virus china",
    "collaborator assures coronavirus manufactured wuhan",
    "concluded covid leaked wuhan lab",
    "coronavirus created united states china",
    "air comes china import coronavirus",
    "coronavirus released china"
  )) |>
  filter(language == "en") |>
  filter(label == "misinformation")

# Distribution of final misinformation topics
table(covid_wuhan_misinfo$keywords)
table(covid_wuhan_misinfo$cluster_keywords)
```

## Social Network Construction

This network models the co-dissemination behavior of misinformation retweeters. While the exact paths of information transmission are unknown, this co-spreader network captures the structural relationships that may facilitate misinformation diffusion.

### Co-Retweet Network

The `co-retweet` network represents a co-dissemination behavior among retweeters. A tie is created between two users only if they both retweeted the same specific misinformation tweet, which is identified by a shared `tweet_id` in `user_retweeted_tweet.csv` file. Each edge is weighted by the number of such co-retweeting events, reflecting how often the same pair of users jointly retweeted the same pieces of misinformation. Though this relationship does not suggest that a paired users share the same opinion, it captures direct and synchronous amplification of specific misinformation claim in tweets. Therefore, by analyzing the weighted connections among pairs of retweeters, this network checks which retweeters are central to the misinformation amplification/dissemination process, and whether specific communities or cliques form around the repeated propagation of misinformation.

```{r}
# Extract misinformation-related tweets id
misinfo_tweet_id <- unique(covid_wuhan_misinfo$tweet_id)

# Identify pairs of users who co-retweeted the same misinformation tweet
co_retweet_edges <- user_retweet |> 
  filter(tgt %in% misinfo_tweet_id) |> 
  rename(tweet_id = tgt, retweeter_id = src) |> 
  group_by(tweet_id) |> 
  summarise(
    pairs = list(as.data.frame(t(combn(retweeter_id, 2)))), 
    .groups = "drop"
  ) |> 
  unnest(pairs) |> 
  mutate(
    user_1 = pmin(V1, V2), # Ensure lower ID comes first
    user_2 = pmax(V1, V2) # Ensure higher ID comes second
  ) |> 
  select(user_1, user_2) |> 
  group_by(user_1, user_2) |> 
  summarise(weight = n(), .groups = "drop") |> 
  mutate(type = "co-retweet") |>
  filter(user_1 != user_2) |>
  mutate(
    user_1 = as.character(user_1),
    user_2 = as.character(user_2)
  )

# Obtain the full list of unique users involved
all_retweeters <- unique(c(
  covid_wuhan_misinfo$retweeter_id,  
  co_retweet_edges$user_1, 
  co_retweet_edges$user_2
)) |> 
  as.character() |> 
  sort()

# Create initial matrix
adj_matrix_co_retweet <- acast(
  co_retweet_edges, 
  user_1 ~ user_2, 
  value.var = "weight", 
  fill = 0
)

# Ensure matrix completeness by adding missing rows and columns
missing_rows <- setdiff(all_retweeters, rownames(adj_matrix_co_retweet))
missing_cols <- setdiff(all_retweeters, colnames(adj_matrix_co_retweet))

if (length(missing_rows) > 0) {
  adj_matrix_co_retweet <- rbind(
    adj_matrix_co_retweet, 
    matrix(0, nrow = length(missing_rows), ncol = ncol(adj_matrix_co_retweet), 
           dimnames = list(missing_rows, colnames(adj_matrix_co_retweet)))
  )
}

if (length(missing_cols) > 0) {
  adj_matrix_co_retweet <- cbind(
    adj_matrix_co_retweet, 
    matrix(0, nrow = nrow(adj_matrix_co_retweet), ncol = length(missing_cols), 
           dimnames = list(rownames(adj_matrix_co_retweet), missing_cols))
  )
}

# Reorder the matrix to align rows and columns
adj_matrix_co_retweet <- adj_matrix_co_retweet[all_retweeters, all_retweeters]

# Export the adjacency matrix for further analysis
write.csv(adj_matrix_co_retweet, "data/adj_matrix_co_retweet.csv", row.names = TRUE)

# Check dimensions of the final matrix
ncol(adj_matrix_co_retweet)
nrow(adj_matrix_co_retweet)

table(co_retweet_edges$weight)
```

### Co-Retweet (Quote Pathway)

The **Co-Retweet (Quote Pathway)** Network captures relational ties between users who both engaged in the dissemination (i.e., retweeting) of misinformation content either by a) retweeting original misinformation tweets, or b) retweeting tweets that explicitly quoting misinformation tweets. In this network, a tie is formed between two users if they each retweeted at least one tweet that is either a misinformation tweet or a tweet quoting misinformation pieces.

```{r}
# Load quote relationships between tweets (quoting tweet & quoted tweet)

quote_relations <- read_csv("data/mumin_csv/reply_quote_of_tweet.csv") |>
  filter(tgt %in% misinfo_tweet_id | src %in% misinfo_tweet_id) |> 
  rename(
    quoted_tweet_id = tgt, # The misinformation tweet being quoted
    quoting_tweet_id = src # The tweet that quotes the misinformation tweet
  )

# Create the complete set of tweets relevant to the quote pathway
quote_path_tweet_ids <- unique(c(
  quote_relations$quoted_tweet_id , # Original misinformation tweets
  quote_relations$quoting_tweet_id # Tweets that quoted misinformation
))

# Find all users who retweeted these tweets
quote_path_retweets <- covid_wuhan_misinfo |> 
  filter(tweet_id %in% quote_path_tweet_ids) 

# Generate co-retweet edges based on shared retweeting of these tweets
co_retweet_quote_path_edges <- quote_path_retweets |>
  group_by(tweet_id) |>
  summarise(
    pairs = list(as.data.frame(t(combn(retweeter_id, 2)))), 
    .groups = "drop"
  ) |>
  unnest(pairs) |>
  mutate(
    user_1 = pmin(V1, V2),
    user_2 = pmax(V1, V2)
  ) |>
  select(user_1, user_2) |>
  group_by(user_1, user_2) |>
  summarise(weight = n(), .groups = "drop") |>
  mutate(type = "co-retweet-quote-path") |>
  filter(user_1 != user_2) |> 
  mutate(
    user_1 = as.character(user_1),
    user_2 = as.character(user_2)
  )

# Prepare full user list
all_retweeters_quote <- unique(c(
  covid_wuhan_misinfo$retweeter_id, 
  co_retweet_quote_path_edges$user_1, 
  co_retweet_quote_path_edges$user_2
)) |> 
  as.character() |> 
  sort()

# Create the adjacency matrix
adj_matrix_co_retweet_quote_path <- acast(
  co_retweet_quote_path_edges, 
  user_1 ~ user_2, 
  value.var = "weight", 
  fill = 0
)

# Add missing rows and columns to complete the matrix
missing_rows <- setdiff(all_retweeters_quote, rownames(adj_matrix_co_retweet_quote_path))
missing_cols <- setdiff(all_retweeters_quote, colnames(adj_matrix_co_retweet_quote_path))

if (length(missing_rows) > 0) {
  adj_matrix_co_retweet_quote_path <- rbind(
    adj_matrix_co_retweet_quote_path, 
    matrix(0, nrow = length(missing_rows), ncol = ncol(adj_matrix_co_retweet_quote_path), 
           dimnames = list(missing_rows, colnames(adj_matrix_co_retweet_quote_path)))
  )
}

if (length(missing_cols) > 0) {
  adj_matrix_co_retweet_quote_path <- cbind(
    adj_matrix_co_retweet_quote_path, 
    matrix(0, nrow = nrow(adj_matrix_co_retweet_quote_path), ncol = length(missing_cols), 
           dimnames = list(rownames(adj_matrix_co_retweet_quote_path), missing_cols))
  )
}

# Ensure matrix symmetry and proper ordering
adj_matrix_co_retweet_quote_path <- adj_matrix_co_retweet_quote_path[all_retweeters_quote, all_retweeters_quote]

# Save the matrix for further analysis
write.csv(adj_matrix_co_retweet_quote_path, "data/adj_matrix_co_retweet_quote_path.csv", row.names = TRUE)

# Output matrix dimensions for verification
nrow(adj_matrix_co_retweet_quote_path)
ncol(adj_matrix_co_retweet_quote_path)

table(co_retweet_quote_path_edges$weight)

```

```{r}
quote_data <-read_csv("data/mumin_csv/reply_quote_of_tweet.csv")

sum(quote_data$src %in% misinfo_tweet_id)

sum(quote_data$tgt %in% misinfo_tweet_id)

sum(misinfo_tweet_id %in% quote_data$tgt)

sum(misinfo_tweet_id %in% c(quote_data$src,quote_data$tgt))

```

### Co-Retweet (Reply Pathway)

The **Co-Retweet (Reply Pathway)** Network captures relational ties between users who both retweeted tweets directly involved in misinformation discussions, either by a) retweeting misinformation tweets themselves, or b) retweeting the tweets that explicitly replied to such misinformation content.

```{r}
# Load reply relationships to identify reply chains around misinformation
reply_relations <- read_csv("data/mumin_csv/reply_reply_to_tweet.csv") |>
  filter(tgt %in% misinfo_tweet_id | src %in% misinfo_tweet_id) |> 
  rename(
    replied_tweet_id = tgt, # The misinformation tweet being replied to
    replying_tweet_id = src # The tweet that replies to the misinformation tweet
  )

# Step 1: Create complete set of tweets involved in reply chains related to misinformation
reply_path_tweet_ids <- unique(c(
  reply_relations$replied_tweet_id, 
  reply_relations$replying_tweet_id
))

# Step 2: Find all users who retweeted these tweets (participating in the reply pathway)
reply_path_retweets <- covid_wuhan_misinfo |> 
  filter(tweet_id %in% reply_path_tweet_ids)

# Step 3: Generate Co-Reply Edges based on shared retweeting of reply-path tweets
co_retweet_reply_path_edges <- reply_path_retweets |>
  group_by(tweet_id) |>
  summarise(
    pairs = list(as.data.frame(t(combn(retweeter_id, 2)))), 
    .groups = "drop"
  ) |>
  unnest(pairs) |>
  mutate(
    user_1 = pmin(V1, V2), 
    user_2 = pmax(V1, V2)
  ) |>
  select(user_1, user_2) |>
  group_by(user_1, user_2) |>
  summarise(weight = n(), .groups = "drop") |>
  mutate(type = "co-retweet-reply-path") |>
  filter(user_1 != user_2) |>
  mutate(
    user_1 = as.character(user_1),
    user_2 = as.character(user_2)
  )

# Prepare full user list
all_retweeters_reply <- unique(c(
  covid_wuhan_misinfo$retweeter_id, 
  co_retweet_reply_path_edges$user_1, 
  co_retweet_reply_path_edges$user_2
)) |> 
  as.character() |> 
  sort()

# Create the adjacency matrix
adj_matrix_co_retweet_reply_path <- acast(
  co_retweet_reply_path_edges, 
  user_1 ~ user_2, 
  value.var = "weight", 
  fill = 0
)

# Add missing rows and columns to complete the matrix
missing_rows <- setdiff(all_retweeters_reply, rownames(adj_matrix_co_retweet_reply_path))
missing_cols <- setdiff(all_retweeters_reply, colnames(adj_matrix_co_retweet_reply_path))

if (length(missing_rows) > 0) {
  adj_matrix_co_retweet_reply_path <- rbind(
    adj_matrix_co_retweet_reply_path, 
    matrix(0, nrow = length(missing_rows), ncol = ncol(adj_matrix_co_retweet_reply_path), 
           dimnames = list(missing_rows, colnames(adj_matrix_co_retweet_reply_path)))
  )
}

if (length(missing_cols) > 0) {
  adj_matrix_co_retweet_reply_path <- cbind(
    adj_matrix_co_retweet_reply_path, 
    matrix(0, nrow = nrow(adj_matrix_co_retweet_reply_path), ncol = length(missing_cols), 
           dimnames = list(rownames(adj_matrix_co_retweet_reply_path), missing_cols))
  )
}

# Ensure matrix symmetry and proper ordering
adj_matrix_co_retweet_reply_path <- adj_matrix_co_retweet_reply_path[all_retweeters_reply, all_retweeters_reply]

# Save the matrix for further analysis
write.csv(adj_matrix_co_retweet_reply_path, "data/adj_matrix_co_retweet_reply_path.csv", row.names = TRUE)

# Output matrix dimensions for verification
nrow(adj_matrix_co_retweet_reply_path)
ncol(adj_matrix_co_retweet_reply_path)

table(co_retweet_reply_path_edges$weight)
```

### Follow

A directed edge from User A to User B indicates that User A follows User B. This network captures the potential flow of influence among misinformation retweeters and allows for the identification of opinion leaders and hierarchical structures in misinformation diffusion.

```{r}
# Load retweeter list
retweeter_id_misinfo <- unique(covid_wuhan_misinfo$retweeter_id)

# Load and filter directed follow edges
retweeter_follow_edges_directed <- read_csv("data/mumin_csv/user_follows_user.csv") |> 
  rename(follower = src, followee = tgt) |> 
  filter(follower %in% retweeter_id_misinfo & followee %in% retweeter_id_misinfo) |> 
  mutate(weight = 1, type = "follow_directed") |> 
  select(follower, followee, weight, type)

# Check if any edges exist
if (nrow(retweeter_follow_edges_directed) == 0) {
  message("No directed follow relationships found among misinformation retweeters.")
} else {
  # Create adjacency matrix
  all_retweeters <- sort(unique(c(
    covid_wuhan_misinfo$retweeter_id, 
    retweeter_follow_edges_directed$follower, 
    retweeter_follow_edges_directed$followee
  ))) |> as.character()

  adj_matrix_follow_directed <- matrix(
    0, 
    nrow = length(all_retweeters), 
    ncol = length(all_retweeters),
    dimnames = list(all_retweeters, all_retweeters)
  )

  # Fill matrix with edges
  apply(retweeter_follow_edges_directed, 1, function(row) {
    adj_matrix_follow_directed[row["follower"], row["followee"]] <<- 1
  })

  # Save matrix
  write.csv(adj_matrix_follow_directed, "data/adj_matrix_follow_directed.csv", row.names = TRUE)
}
```

Analysis of the follower network among misinformation retweeters revealed no recorded follower-followee relationships within this group. This indicates that users involved in the dissemination of COVID-19 origin misinformation acted largely as isolated agents rather than as members of a tightly connected social network. Such a pattern suggests that the spread of misinformation in this case was driven primarily by content virality and opportunistic engagement, rather than through established social ties or influencer-led dissemination.

# Analysis

## Basic Network Metrics

### Compare 3 Networks overall difference

```{r}
# 1. 读入三个网络的邻接矩阵
adj_direct <- as.matrix(read.csv("data/adj_matrix_co_retweet.csv", row.names = 1, check.names = FALSE))
adj_quote <- as.matrix(read.csv("data/adj_matrix_co_retweet_quote_path.csv", row.names = 1, check.names = FALSE))
adj_reply <- as.matrix(read.csv("data/adj_matrix_co_retweet_reply_path.csv", row.names = 1, check.names = FALSE))

# 2. 转换为 statnet 的 network 对象
net_direct <- network(adj_direct, directed = FALSE, matrix.type = "adjacency")
net_quote <- network(adj_quote, directed = FALSE, matrix.type = "adjacency")
net_reply <- network(adj_reply, directed = FALSE, matrix.type = "adjacency")

# 3. 定义计算函数
compute_network_metrics <- function(net) {
  data.frame(
    Nodes = network.size(net),
    Edges = network.edgecount(net),
    Density = gden(net),
    Average_Degree = mean(degree(net), na.rm = TRUE),
    Transitivity = gtrans(net, mode = "graph"),
    Centralization_Degree = centralization(net, degree, mode = "freeman")
  )
}

# 4. 计算各网络的指标
metrics_direct <- compute_network_metrics(net_direct)
metrics_quote <- compute_network_metrics(net_quote)
metrics_reply <- compute_network_metrics(net_reply)

# 5. 合并结果输出
metrics_result <- rbind(
  cbind(Network = "Direct Co-Retweet", metrics_direct),
  cbind(Network = "Quote Pathway", metrics_quote),
  cbind(Network = "Reply Pathway", metrics_reply)
)

print(metrics_result)


plot(net_direct)
plot(net_quote)
plot(net_reply)
```

### T-Test

```{r}
# # 创建数据框手动输入结果
# metrics_df <- data.frame(
#   Network = c("Direct", "Quote", "Reply"),
#   Density = c(0.1309, 0.0838, 0.0894),
#   Centralization = c(0.0868, 0.1348, 0.1291)
# )
# 
# # t-test: Density Direct vs Quote
# t.test_density_dq <- t.test(
#   x = rep(metrics_df$Density[1], 112),  # Direct
#   y = rep(metrics_df$Density[2], 112)   # Quote
# )
# 
# # t-test: Density Direct vs Reply
# t.test_density_dr <- t.test(
#   x = rep(metrics_df$Density[1], 112),  # Direct
#   y = rep(metrics_df$Density[3], 112)   # Reply
# )
# 
# # t-test: Centralization Direct vs Quote
# t.test_cent_dq <- t.test(
#   x = rep(metrics_df$Centralization[1], 112),
#   y = rep(metrics_df$Centralization[2], 112)
# )
# 
# # 查看结果
# t.test_density_dq
# t.test_density_dr
# t.test_cent_dq


```

### Co-retweet Net

```{r}
# Load 6 Stage Net
co_retweet_stage_networks <- list(
  Stage1 = read.csv("data/adj_matrix_stage1.csv", row.names = 1) |> 
    as.matrix() |> 
    network(directed = FALSE, matrix.type = "adjacency"),
  
  Stage2 = read.csv("data/adj_matrix_stage2.csv", row.names = 1) |> 
    as.matrix() |> 
    network(directed = FALSE, matrix.type = "adjacency"),
  
  Stage3 = read.csv("data/adj_matrix_stage3.csv", row.names = 1) |> 
    as.matrix() |> 
    network(directed = FALSE, matrix.type = "adjacency"),
  
  Stage4 = read.csv("data/adj_matrix_stage4.csv", row.names = 1) |> 
    as.matrix() |> 
    network(directed = FALSE, matrix.type = "adjacency"),
  
  Stage5 = read.csv("data/adj_matrix_stage5.csv", row.names = 1) |> 
    as.matrix() |> 
    network(directed = FALSE, matrix.type = "adjacency"),
  
  Stage6 = read.csv("data/adj_matrix_stage6.csv", row.names = 1) |> 
    as.matrix() |> 
    network(directed = FALSE, matrix.type = "adjacency")
)

```

```{r}

compute_local_clustering <- function(net) {
  adj_mat <- as.matrix.network.adjacency(net)
  n <- nrow(adj_mat)
  
  clustering_vals <- numeric(n)
  
  for (i in 1:n) {
    neighbors <- which(adj_mat[i, ] == 1)
    k <- length(neighbors)
    if (k < 2) {
      clustering_vals[i] <- NA  # 无法形成三角形，设为 NA
    } else {
      subgraph <- adj_mat[neighbors, neighbors]
      actual_edges <- sum(subgraph) / 2  # 无向图
      possible_edges <- k * (k - 1) / 2
      clustering_vals[i] <- actual_edges / possible_edges
    }
  }
  
  return(clustering_vals)
}


compute_metrics <- function(net) {
  data.frame(
    Nodes = network.size(net),
    Edges = network.edgecount(net),
    Density = gden(net),
    Average_Degree = mean(degree(net), na.rm = TRUE),
    Degree_Centralization = centralization(net, degree, mode = "freeman"),
    Closeness_Centralization = centralization(net, closeness, mode = "freeman"),
    Betweenness_Centralization = centralization(net, betweenness, mode = "freeman"),
    Transitivity_Global = gtrans(net, mode = "graph"),
    Transitivity_Local = mean(compute_local_clustering(net), na.rm = TRUE)  # 替代 clustering.coefficient
  )
}


```

```{r}
metrics_results <- lapply(co_retweet_stage_networks, compute_metrics)
metrics_df <- do.call(rbind, metrics_results)
metrics_df$Stage <- rownames(metrics_df)

# reorder columns
metrics_df <- metrics_df[, c("Stage", setdiff(names(metrics_df), "Stage"))]

print(metrics_df)

```

The analysis of basic network metrics across the six stages reveals a highly clustered network structure with consistently high global and local transitivity values, suggesting that misinformation retweet activities predominantly occurred within tightly-knit groups. Notably, Stage 2 exhibits the highest average degree and network density, indicating peak activity and diffusion potential at this stage. Conversely, low centralization scores across closeness and betweenness measures imply the absence of prominent gatekeepers or highly influential intermediaries within the network.

# Reference

Bruns, A., Harrington, S., & Hurcombe, E. (2020). Corona? 5G? or both? The dynamics of COVID-19 conspiracy theories on Facebook. *Media International Australia, 177*(1), 12–29. <https://doi.org/10.1177/1329878X20946113>

Cinelli, M., Quattrociocchi, W., Galeazzi, A., et al. (2020). The COVID-19 social media infodemic. *Scientific Reports, 10*, 16598. <https://doi.org/10.1038/s41598-020-73510-5>

Ferrara, E. (2020). What types of COVID-19 conspiracies are populated by Twitter bots? *First Monday, 25*(6). <https://doi.org/10.5210/fm.v25i6.10633>

Guarino, S., Trino, N., Celestini, A., Chessa, A., & Riotta, G. (2020). Characterizing networks of propaganda on Twitter: A case study. *Applied Network Science, 5*, 59. <https://doi.org/10.1007/s41109-020-00286-y>

Guess, A., Nagler, J., & Tucker, J. (2019). Less than you think: Prevalence and predictors of fake news dissemination on Facebook. *Science Advances, 5*(1), eaau4586. <https://doi.org/10.1126/sciadv.aau4586>

Shao, C., Ciampaglia, G. L., Varol, O., et al. (2018). The spread of low-credibility content by social bots. *Nature Communications, 9*, 4787. <https://doi.org/10.1038/s41467-018-06930-7>

Stam, C., Saldanha, E., Halappanavar, M., & Acharya, A. (2024). DISHONEST: Dissecting misinformation spread using homogeneous social networks and semantic topic classification. arXiv preprint arXiv:2412.09578. https://arxiv.org/abs/2412.09578

Truong, B. T., Hui, P.-M., Torres-Lugo, C., Pacheco, D., Flammini, A., & Menczer, F. (2021). Uncovering coordinated networks on social media. Proceedings of the International AAAI Conference on Web and Social Media, 15(1), 455–466. https://doi.org/10.1609/icwsm.v15i1.18075

Vosoughi, S., Roy, D., & Aral, S. (2018). The spread of true and false news online. *Science, 359*(6380), 1146–1151. <https://doi.org/10.1126/science.aap9559>

Wasserman, S., & Faust, K. (1994). *Social Network Analysis: Methods and Applications*. Cambridge University Press.

Weber, D., & Neumann, F. (2021). Amplifying influence through coordinated behaviour in social networks. Social Network Analysis and Mining, 11(1), 1–13. https://doi.org/10.1007/s13278-021-00815-2

Wu, Y., & Shen, H. (2023). Examining retweeting behavior on social networking sites from the perspective of online identity and self-presentation. Frontiers in Psychology, 14, 10202284. https://doi.org/10.3389/fpsyg.2023.10202284

Zhao, Z., & Wang, X. (2024). To Reply or to Quote: Comparing conversational framing strategies on Twitter. Proceedings of the ACM on Human-Computer Interaction, 8(CSCW1), Article 3625680. https://doi.org/10.1145/3625680

# Appendix

## Data Collection

This study uses secondary data from the **MuMiN Project** (Multi-platform Misinformation Influence Network), publicly available at: <https://data.bris.ac.uk/datasets/23yv276we2mll25fjakkfim2ml/mumin.zip> The dataset includes information about retweeter ids, tweets ids, misinformation claims, and the date when specific misinformation claims uttered etc.

**Note: About the `date`, [the explanation of dataset's authours](https://arxiv.org/abs/2202.11684):**

*"`date`: The date the claim was uttered. If this date was not available then the date of the review was used. If neither of those two were available then we extracted a potential date from the URL of the fact-checking article using the regular expression \[0-9\]{4}-\[0-9\]{2}-\[0-9\]{2}."*

After downloading all files, create a `data` folder in your working directory and place the files inside it. Then, follow the setup instructions provided [here](https://colab.research.google.com/drive/1JCjgg3moGBOuZk4iVjBpQNqgsAYFyNoS#scrollTo=YS1uxj-59UmA). Use the shell to install required packages via `pip` as directed. Next, open `VS Code`, and run the following Python script to convert `.pkl` files to `.csv`:

```{python}
#| eval: false
#| include: true

import pandas as pd
import os

input_dir = "data/mumin"
output_dir = "data/mumin_csv"
os.makedirs(output_dir, exist_ok=True)

file_names = [
    "claim",
    "user",
    "tweet",
    "reply",
    "article",
    "tweet_discusses_claim",
    "article_discusses_claim",
    "user_follows_user",
    "user_retweeted_tweet",
    "reply_quote_of_tweet",
    "reply_reply_to_tweet"
]

for name in file_names:
    input_path = os.path.join(input_dir, name)
    output_path = os.path.join(output_dir, f"{name}.csv")
    try:
        df = pd.read_pickle(input_path, compression="xz")
        df.to_csv(output_path, index=False)
        print(f"Saved: {output_path}")
    except Exception as e:
        print(f"Failed to convert {name}: {e}")

```

This script will generate the corresponding CSV files for further analysis.

**Note:** *If you have a [X Developer API Pro Account](https://developer.x.com/en/portal/products/pro), you can directly follow the dataset's authors' [MuMiN Tutorial](https://colab.research.google.com/drive/1JCjgg3moGBOuZk4iVjBpQNqgsAYFyNoS#scrollTo=YS1uxj-59UmA) and conduct a deeper analysis with more enriched variables when [rehydrating the original datasets](https://colab.research.google.com/drive/1JCjgg3moGBOuZk4iVjBpQNqgsAYFyNoS#scrollTo=bOQqaJOa_PbF&line=1&uniqifier=1).*

After all steps above done, you can review the data in R:

```{r}
#| eval: false
#| include: true
# Set the data path 
data_path <- "data/mumin_csv/"

# Define the list of files to read
files <- c(
  "claim.csv", "user.csv", "tweet.csv", "reply.csv", "article.csv",
  "tweet_discusses_claim.csv", "article_discusses_claim.csv",
  "user_follows_user.csv", "user_retweeted_tweet.csv",
  "reply_quote_of_tweet.csv", "reply_reply_to_tweet.csv"
)

# Preview the first few rows of each file 
previews <- lapply(files, function(fname) {
  fpath <- file.path(data_path, fname)
  tryCatch(
    read_csv(fpath, n_max = 5),
    error = function(e) tibble::tibble(error = paste("Error:", e$message))
  )
})

names(previews) <- files

```

## Data Preparation

### Loading Required Packages

```{r}
#| eval: false
library(tidyverse)
library(readr)
library(statnet)
library(intergraph)
library(reshape2)
library(btergm)
library(igraph)
```

### Loading and Merging Data

```{r}
#| eval: false
# Load data
tweets <- read_csv("data/mumin_csv/tweet.csv")
claims <- read_csv("data/mumin_csv/claim.csv")
tweet_claim <- read_csv("data/mumin_csv/tweet_discusses_claim.csv")
user_retweet <- read_csv("data/mumin_csv/user_retweeted_tweet.csv")

# Join tweet & claim via tweet_claim
tweet_claim_joined <- tweet_claim |> 
  rename(tweet_id = src, claim_id = tgt) |> 
  inner_join(claims, by = c("claim_id" = "id"))

# Join retweeters within users & claim via retweeted tweet
user_claim <- user_retweet |> 
  rename(retweeter_id = src, tweet_id = tgt) |> 
  inner_join(tweet_claim_joined, by = "tweet_id")

# Create a mapping of retweeters and tweets
retweet_map <- user_claim |> 
  select(retweeter_id, tweet_id) |> 
  distinct() 

# Basic data overview
table(user_claim$label)
head(table(user_claim$cluster_keywords))
```

### Filtering for Target Misinformation Narratives

This study focuses specifically on misinformation narratives claiming that **COVID-19 was deliberately created or spread by China or the Wuhan laboratory**. The following filtering steps were applied:

```{r}
#| eval: false
# Filter keywords containing "china" or "wuhan"
user_claim_filtered <- user_claim |> 
  filter(str_detect(keywords, "china|wuhan")) 

head(unique(user_claim_filtered$keywords))

# Manually select misinformation topics directly related to the COVID-19 origin narrative
covid_wuhan_misinfo <- user_claim_filtered |>
  filter(keywords %in% c(
    "coronavirus comes biological laboratory wuhan",
    "including corona virus manufactured wuhan",
    "china created spread coronavirus",
    "announced coronavirus artificially created china",
    "china created coronavirus",
    "coronavirus created laboratory china",
    "honjo said china manufactured coronavirus",
    "said new coronavirus manufactured wuhan",
    "coronavirus tested biological weapon china",
    "china testing coronavirus biological weapon",
    "covid 19 lab china",
    "coronavirus natural worked wuhan laboratory",
    "coronavirus manufactured laboratory wuhan specifically",
    "doctor claimed coronavirus china create",
    "corona virus manufactured china",
    "says current coronavirus manufactured wuhan",
    "wuhan coronavirus created patented",
    "covid 19 disease manufactured china",
    "pandemic caused artificial virus china",
    "collaborator assures coronavirus manufactured wuhan",
    "concluded covid leaked wuhan lab",
    "coronavirus created united states china",
    "air comes china import coronavirus",
    "coronavirus released china"
  )) |>
  # Restrict the analysis to English-language posts labeled as "misinformation"
  filter(language == "en") |>
  filter(label == "misinformation")

# Distribution of final misinformation topics
table(covid_wuhan_misinfo$keywords)
table(covid_wuhan_misinfo$cluster_keywords)
```

## Social Network Construction

This network models the co-dissemination behavior of misinformation retweeters. While the exact paths of information transmission are unknown, this co-spreader network captures the structural relationships that may facilitate misinformation diffusion.

### Co-Retweet Network

The `co-retweet` network represents a co-dissemination behavior among retweeters. A tie is created between two users only if they both retweeted the same specific misinformation tweet, which is identified by a shared `tweet_id` in `user_retweeted_tweet.csv` file. Each edge is weighted by the number of such co-retweeting events, reflecting how often the same pair of users jointly retweeted the same pieces of misinformation. Though this relationship does not suggest that a paired users share the same opinion, it captures direct and synchronous amplification of specific misinformation claim in tweets. Therefore, by analyzing the weighted connections among pairs of retweeters, this network checks which retweeters are central to the misinformation amplification/dissemination process, and whether specific communities or cliques form around the repeated propagation of misinformation.

```{r}
#| eval: false
# Extract misinformation-related tweets id
misinfo_tweet_id <- unique(covid_wuhan_misinfo$tweet_id)

# Identify pairs of users who co-retweeted the same misinformation tweet
co_retweet_edges <- user_retweet |> 
  filter(tgt %in% misinfo_tweet_id) |> 
  rename(tweet_id = tgt, retweeter_id = src) |> 
  group_by(tweet_id) |> 
  summarise(
    pairs = list(as.data.frame(t(combn(retweeter_id, 2)))), 
    .groups = "drop"
  ) |> 
  unnest(pairs) |> 
  mutate(
    user_1 = pmin(V1, V2), # Ensure lower ID comes first
    user_2 = pmax(V1, V2) # Ensure higher ID comes second
  ) |> 
  select(user_1, user_2) |> 
  group_by(user_1, user_2) |> 
  summarise(weight = n(), .groups = "drop") |> 
  mutate(type = "co-retweet") |>
  filter(user_1 != user_2) |>
  mutate(
    user_1 = as.character(user_1),
    user_2 = as.character(user_2)
  )

# Obtain the full list of unique users involved
all_retweeters <- unique(c(
  covid_wuhan_misinfo$retweeter_id,  
  co_retweet_edges$user_1, 
  co_retweet_edges$user_2
)) |> 
  as.character() |> 
  sort()

# Create initial matrix
adj_matrix_co_retweet <- acast(
  co_retweet_edges, 
  user_1 ~ user_2, 
  value.var = "weight", 
  fill = 0
)

# Ensure matrix completeness by adding missing rows and columns
missing_rows <- setdiff(all_retweeters, rownames(adj_matrix_co_retweet))
missing_cols <- setdiff(all_retweeters, colnames(adj_matrix_co_retweet))

if (length(missing_rows) > 0) {
  adj_matrix_co_retweet <- rbind(
    adj_matrix_co_retweet, 
    matrix(0, nrow = length(missing_rows), ncol = ncol(adj_matrix_co_retweet), 
           dimnames = list(missing_rows, colnames(adj_matrix_co_retweet)))
  )
}

if (length(missing_cols) > 0) {
  adj_matrix_co_retweet <- cbind(
    adj_matrix_co_retweet, 
    matrix(0, nrow = nrow(adj_matrix_co_retweet), ncol = length(missing_cols), 
           dimnames = list(rownames(adj_matrix_co_retweet), missing_cols))
  )
}

# Reorder the matrix to align rows and columns
adj_matrix_co_retweet <- adj_matrix_co_retweet[all_retweeters, all_retweeters]

# Export the adjacency matrix for further analysis
write.csv(adj_matrix_co_retweet, "data/adj_matrix_co_retweet.csv", row.names = TRUE)

# Check dimensions of the final matrix
ncol(adj_matrix_co_retweet)
nrow(adj_matrix_co_retweet)

table(co_retweet_edges$weight)
```

## Graph

### Co-retweet Net

#### Stage 1 Plot (Co-retweet Net)

```{r}
#| output: false
# Load Data and Build Full Network
adj_matrix <- read.csv("data/adj_matrix_co_retweet.csv", row.names = 1, check.names = FALSE)

net_full <- network(as.matrix(adj_matrix), directed = FALSE, matrix.type = "adjacency")

retweeter_stage <- covid_wuhan_misinfo |>
  mutate(retweeter_id = as.character(retweeter_id)) |>
  select(retweeter_id, date, keywords) |>
  distinct() |>
  arrange(date) |>
  mutate(
    group = as.numeric(factor(paste(date, keywords), levels = unique(paste(date, keywords))))
  ) |>
  select(retweeter_id, group, date, keywords)

node_names <- net_full %v% "vertex.names"

assigned_groups <- retweeter_stage$group[match(node_names, retweeter_stage$retweeter_id)]

set.vertex.attribute(net_full, "group", assigned_groups)

# Assign Current Stage Info
target_group <- 1  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)

stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
edgelist <- as.edgelist(net_full)
v1 <- edgelist[, 1]
v2 <- edgelist[, 2]

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage Adjacency Matrix
adj_stage1 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage1) <- colnames(adj_stage1) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage1[v1[idx], v2[idx]] <- 1
    adj_stage1[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 1 Adjacency Matrix
write.csv(adj_stage1, "data/adj_matrix_stage1.csv", row.names = TRUE)

# Build Network Object for Stage 1
net_stage1 <- network(adj_stage1, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)

plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage1, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG
# png("plot/co_retweet_net/Co-Retweet-Stage1.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage1,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 1 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)
```

#### Stage 2 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 2  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 2 Adjacency Matrix
adj_stage2 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage2) <- colnames(adj_stage2) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage2[v1[idx], v2[idx]] <- 1
    adj_stage2[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 2 Adjacency Matrix
write.csv(adj_stage2, "data/adj_matrix_stage2.csv", row.names = TRUE)

# Build Network Object for Stage 2
net_stage2 <- network(adj_stage2, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage2, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG for Stage 2
# png("plot/co_retweet_net/Co-Retweet-Stage2.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage2,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 2 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 3 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 3  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 3 Adjacency Matrix
adj_stage3 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage3) <- colnames(adj_stage3) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage3[v1[idx], v2[idx]] <- 1
    adj_stage3[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 3 Adjacency Matrix
write.csv(adj_stage3, "data/adj_matrix_stage3.csv", row.names = TRUE)

# Build Network Object for Stage 3
net_stage3 <- network(adj_stage3, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage3, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG for Stage 3
# png("plot/co_retweet_net/Co-Retweet-Stage3.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage3,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 3 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)
```

#### Stage 4 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 4  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 4 Adjacency Matrix
adj_stage4 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage4) <- colnames(adj_stage4) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage4[v1[idx], v2[idx]] <- 1
    adj_stage4[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 4 Adjacency Matrix
write.csv(adj_stage4, "data/adj_matrix_stage4.csv", row.names = TRUE)

# Build Network Object for Stage 4
net_stage4 <- network(adj_stage4, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage4, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG for Stage 4
# png("plot/co_retweet_net/Co-Retweet-Stage4.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage4,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 4 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 5 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 5  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Get Edge List and Filter Edges for Current Stage
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 5 Adjacency Matrix
adj_stage5 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage5) <- colnames(adj_stage5) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage5[v1[idx], v2[idx]] <- 1
    adj_stage5[v2[idx], v1[idx]] <- 1
  }
}

# Save Stage 5 Adjacency Matrix
write.csv(adj_stage5, "data/adj_matrix_stage5.csv", row.names = TRUE)

# Build Network Object for Stage 5
net_stage5 <- network(adj_stage5, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage5, 
  gmode = "graph", 
  mode = "kamadakawai"
)

```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# Save PNG for Stage 5
# png("plot/co_retweet_net/Co-Retweet-Stage5.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage5,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

# Add Legend
legend(
  "right",
  legend = c("Stage 5 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 6 Plot (Co-retweet Net)

```{r}
#| output: false
# Assign Current Stage Info
target_group <- 6  

stage_info <- retweeter_stage |> 
  filter(group == target_group) |> 
  distinct(date, keywords)

stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

adj_stage6 <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage6) <- colnames(adj_stage6) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage6[v1[idx], v2[idx]] <- 1
    adj_stage6[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage6, "data/adj_matrix_stage6.csv", row.names = TRUE)

net_stage6 <- network(adj_stage6, directed = FALSE, matrix.type = "adjacency")

plot_title <- paste0("Co-Retweet Network: Stage ", target_group)
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(
  net_stage6, 
  gmode = "graph", 
  mode = "kamadakawai"
)
```

```{r}
vertex_colors <- ifelse(
  assigned_groups == target_group, 
  "steelblue", 
  "gray"
)

# png("plot/co_retweet_net/Co-Retweet-Stage6.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage6,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

mtext(
  text = plot_subtitle,
  side = 1, 
  line = 3, 
  cex = 0.8, 
  family = "serif"
)

# Add Data Source as Footer Note
mtext(
  text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
  side = 1, 
  line = 4.2,
  cex = 0.6, 
  family = "serif"
)

legend(
  "right",
  legend = c("Stage 6 Retweeters", "Other Retweeters"), 
  col = c("steelblue", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

### Quote path Co-retweet Net

#### Stage 1 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Load Adjacency Matrix for Quote Path Co-Retweet
adj_matrix_quote <- read.csv("data/adj_matrix_co_retweet_quote_path.csv", row.names = 1, check.names = FALSE)
net_full_quote <- network(as.matrix(adj_matrix_quote), directed = FALSE, matrix.type = "adjacency")

# Retweeter Stage Information (Assuming covid_wuhan_misinfo is already loaded)
node_names <- net_full_quote %v% "vertex.names"
assigned_groups <- retweeter_stage$group[match(node_names, retweeter_stage$retweeter_id)]
set.vertex.attribute(net_full_quote, "group", assigned_groups)

# Stage 1 Info
target_group <- 1
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Current Stage
edgelist <- as.edgelist(net_full_quote)
v1 <- edgelist[, 1]
v2 <- edgelist[, 2]
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 1 Adjacency Matrix
adj_stage1_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage1_quote) <- colnames(adj_stage1_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage1_quote[v1[idx], v2[idx]] <- 1
    adj_stage1_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage1_quote, "data/adj_matrix_stage1_quote.csv", row.names = TRUE)

# Build Network Object
net_stage1_quote <- network(adj_stage1_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 1"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

edge_alpha <- 0.1 
edge_width <- 0.2  

set.seed(42)
layout_coords <- gplot(net_stage1_quote, 
                       gmode = "graph", 
                       mode = "kamadakawai")
```

```{r}

vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Plot and Save Image
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage1.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage1_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = edge_width,
  edge.col = adjustcolor("black", alpha.f = edge_alpha),
  main = plot_title
)

# Add Subtitle
mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")

# Add Data Source Footer
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

# Add Legend
legend(
  "right",
  legend = c("Stage 1 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 2 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 2 Parameters
target_group <- 2
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 2
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 2 Adjacency Matrix
adj_stage2_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage2_quote) <- colnames(adj_stage2_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage2_quote[v1[idx], v2[idx]] <- 1
    adj_stage2_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage2_quote, "data/adj_matrix_stage2_quote.csv", row.names = TRUE)

# Build Network Object
net_stage2_quote <- network(adj_stage2_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 2"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage2_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage2.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage2_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

# Add Subtitle
mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")

# Add Data Source Footer
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

# Add Legend
legend(
  "right",
  legend = c("Stage 2 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

```

#### Stage 3 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 3 Parameters
target_group <- 3
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 3
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 3 Adjacency Matrix
adj_stage3_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage3_quote) <- colnames(adj_stage3_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage3_quote[v1[idx], v2[idx]] <- 1
    adj_stage3_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage3_quote, "data/adj_matrix_stage3_quote.csv", row.names = TRUE)

# Build Network Object
net_stage3_quote <- network(adj_stage3_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 3"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage3_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage3.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage3_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

# Add Subtitle
mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")

# Add Data Source Footer
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

# Add Legend
legend(
  "right",
  legend = c("Stage 3 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)


```

#### Stage 4 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 4 Parameters
target_group <- 4
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 4
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 4 Adjacency Matrix
adj_stage4_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage4_quote) <- colnames(adj_stage4_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage4_quote[v1[idx], v2[idx]] <- 1
    adj_stage4_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage4_quote, "data/adj_matrix_stage4_quote.csv", row.names = TRUE)

# Build Network Object
net_stage4_quote <- network(adj_stage4_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 4"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage4_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage4.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage4_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

# Add Subtitle
mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")

# Add Data Source Footer
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

# Add Legend
legend(
  "right",
  legend = c("Stage 4 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5                      
)

dev.off()

```

#### Stage 5 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 5 Parameters
target_group <- 5
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 5
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 5 Adjacency Matrix
adj_stage5_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage5_quote) <- colnames(adj_stage5_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage5_quote[v1[idx], v2[idx]] <- 1
    adj_stage5_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage5_quote, "data/adj_matrix_stage5_quote.csv", row.names = TRUE)

# Build Network Object
net_stage5_quote <- network(adj_stage5_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 5"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage5_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage5.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage5_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 5 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6, 
  text.col = "black", 
  bty = "n", 
  y.intersp = 1.5
)

```

#### Stage 6 Plot (Quote path Co-retweet Net)

```{r}
#| output: false
# Stage 6 Parameters
target_group <- 6
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 6
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 6 Adjacency Matrix
adj_stage6_quote <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage6_quote) <- colnames(adj_stage6_quote) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage6_quote[v1[idx], v2[idx]] <- 1
    adj_stage6_quote[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage6_quote, "data/adj_matrix_stage6_quote.csv", row.names = TRUE)

# Build Network Object
net_stage6_quote <- network(adj_stage6_quote, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Quote Path Co-Retweet Network: Stage 6"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage6_quote, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "darkorange", "gray")

# Save PNG
# png("plot/quote_path_net/Quote-Path-Co-Retweet-Stage6.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage6_quote,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 6 Retweeters", "Other Retweeters"), 
  col = c("darkorange", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6, 
  text.col = "black", 
  bty = "n", 
  y.intersp = 1.5
)

```

### Reply path Co-retweet Net

#### Stage 1 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
# Load Data
adj_matrix_reply <- read.csv("data/adj_matrix_co_retweet_reply_path.csv", row.names = 1, check.names = FALSE)
net_full_reply <- network(as.matrix(adj_matrix_reply), directed = FALSE, matrix.type = "adjacency")

node_names <- net_full_reply %v% "vertex.names"
assigned_groups <- retweeter_stage$group[match(node_names, retweeter_stage$retweeter_id)]
set.vertex.attribute(net_full_reply, "group", assigned_groups)

# Stage 1 Settings
target_group <- 1
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Edges Filtering
edgelist_reply <- as.edgelist(net_full_reply)
v1 <- edgelist_reply[, 1]
v2 <- edgelist_reply[, 2]
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Adjacency Matrix for Stage 1
adj_stage1_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage1_reply) <- colnames(adj_stage1_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage1_reply[v1[idx], v2[idx]] <- 1
    adj_stage1_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage1_reply, "data/adj_matrix_stage1_reply.csv", row.names = TRUE)
net_stage1_reply <- network(adj_stage1_reply, directed = FALSE, matrix.type = "adjacency")

# Visualization
plot_title <- "Reply Path Co-Retweet Network: Stage 1"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)
set.seed(42)
layout_coords <- gplot(net_stage1_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# Save PNG
# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage1.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage1_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 1 Retweeters", "Other Retweeters"), 
  col = c("forestgreen", "gray"), 
  pch = 19, pt.cex = 1, cex = 0.6, 
  text.col = "black", bty = "n", y.intersp = 1.5
)

```

#### Stage 2 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
# Stage 2 Parameters
target_group <- 2
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 2
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 2 Adjacency Matrix
adj_stage2_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage2_reply) <- colnames(adj_stage2_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage2_reply[v1[idx], v2[idx]] <- 1
    adj_stage2_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage2_reply, "data/adj_matrix_stage2_reply.csv", row.names = TRUE)

# Build Network Object
net_stage2_reply <- network(adj_stage2_reply, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Reply Path Co-Retweet Network: Stage 2"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage2_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# Save PNG
# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage2.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage2_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 2 Retweeters", "Other Retweeters"), 
  col = c("forestgreen", "gray"), 
  pch = 19, pt.cex = 1, cex = 0.6, 
  text.col = "black", bty = "n", y.intersp = 1.5
)

```

#### Stage 3 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
# Stage 3 Parameters
target_group <- 3
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

# Filter Edges for Stage 3
group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

# Build Stage 3 Adjacency Matrix
adj_stage3_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage3_reply) <- colnames(adj_stage3_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage3_reply[v1[idx], v2[idx]] <- 1
    adj_stage3_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage3_reply, "data/adj_matrix_stage3_reply.csv", row.names = TRUE)

# Build Network Object
net_stage3_reply <- network(adj_stage3_reply, directed = FALSE, matrix.type = "adjacency")

# Visualization Settings
plot_title <- "Reply Path Co-Retweet Network: Stage 3"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, 
                        " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage3_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# Save PNG
# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage3.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage3_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 3 Retweeters", "Other Retweeters"), 
  col = c("forestgreen", "gray"), 
  pch = 19, 
  pt.cex = 1,  
  cex = 0.6,                    
  text.col = "black", 
  bty = "n",                    
  y.intersp = 1.5
)
```

#### Stage 4 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
target_group <- 4
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

adj_stage4_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage4_reply) <- colnames(adj_stage4_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage4_reply[v1[idx], v2[idx]] <- 1
    adj_stage4_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage4_reply, "data/adj_matrix_stage4_reply.csv", row.names = TRUE)
net_stage4_reply <- network(adj_stage4_reply, directed = FALSE, matrix.type = "adjacency")

plot_title <- "Reply Path Co-Retweet Network: Stage 4"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage4_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage4.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage4_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)", 
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 4 Retweeters", "Other Retweeters"), 
  col = c("forestgreen", "gray"), 
  pch = 19, pt.cex = 1, cex = 0.6, 
  text.col = "black", bty = "n", y.intersp = 1.5
)


```

#### Stage 5 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
target_group <- 5
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

adj_stage5_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage5_reply) <- colnames(adj_stage5_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage5_reply[v1[idx], v2[idx]] <- 1
    adj_stage5_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage5_reply, "data/adj_matrix_stage5_reply.csv", row.names = TRUE)
net_stage5_reply <- network(adj_stage5_reply, directed = FALSE, matrix.type = "adjacency")

plot_title <- "Reply Path Co-Retweet Network: Stage 5"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage5_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage5.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage5_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)",
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 5 Retweeters", "Other Retweeters"),
  col = c("forestgreen", "gray"),
  pch = 19, pt.cex = 1, cex = 0.6,
  text.col = "black", bty = "n", y.intersp = 1.5
)

```

#### Stage 6 Plot (Reply path Co-retweet Net)

```{r}
#| output: false
target_group <- 6
stage_info <- retweeter_stage |> filter(group == target_group) |> distinct(date, keywords)
stage_date <- unique(stage_info$date)
stage_keywords <- unique(stage_info$keywords)

group_v1 <- assigned_groups[v1]
group_v2 <- assigned_groups[v2]
keep_edges <- which(group_v1 == target_group & group_v2 == target_group)

adj_stage6_reply <- matrix(0, nrow = length(node_names), ncol = length(node_names))
rownames(adj_stage6_reply) <- colnames(adj_stage6_reply) <- node_names

if (length(keep_edges) > 0) {
  for (idx in keep_edges) {
    adj_stage6_reply[v1[idx], v2[idx]] <- 1
    adj_stage6_reply[v2[idx], v1[idx]] <- 1
  }
}

write.csv(adj_stage6_reply, "data/adj_matrix_stage6_reply.csv", row.names = TRUE)
net_stage6_reply <- network(adj_stage6_reply, directed = FALSE, matrix.type = "adjacency")

plot_title <- "Reply Path Co-Retweet Network: Stage 6"
plot_subtitle <- paste0("Misinformation Claim: ", stage_keywords, " | Claim Uttered on: ", stage_date)

set.seed(42)
layout_coords <- gplot(net_stage6_reply, gmode = "graph", mode = "kamadakawai")
```

```{r}
vertex_colors <- ifelse(assigned_groups == target_group, "forestgreen", "gray")

# png("plot/reply_path_net/Reply-Path-Co-Retweet-Stage6.png", width = 2200, height = 2100, res = 300)
par(family = "serif", mar = c(6, 0, 3, 1))

plot.network(
  net_stage6_reply,
  displaylabels = FALSE,
  vertex.cex = 1,
  vertex.col = vertex_colors,
  coord = layout_coords,
  edge.lwd = 0.2,
  edge.col = adjustcolor("black", alpha.f = 0.1),
  main = plot_title
)

mtext(text = plot_subtitle, side = 1, line = 3, cex = 0.8, family = "serif")
mtext(text = "Data Source: MuMiN Dataset (https://data.bristol.ac.uk/data/en_GB/dataset/23yv276we2mll25fjakkfim2ml)",
      side = 1, line = 4.2, cex = 0.6, family = "serif")

legend(
  "right",
  legend = c("Stage 6 Retweeters", "Other Retweeters"),
  col = c("forestgreen", "gray"),
  pch = 19, pt.cex = 1, cex = 0.6,
  text.col = "black", bty = "n", y.intersp = 1.5
)
```

## Data Analysis

### Expected findings based on hypotheses

### Actual findings from SNA analysis


```{r}
calculate_metrics_statnet <- function(csv_path, network_type, stage) {
  adj_matrix <- as.matrix(read.csv(csv_path, row.names = 1))
  net <- network(adj_matrix, directed = FALSE, matrix.type = "adjacency")
  
  if (network.size(net) <= 1) {
    return(data.frame(
      Network_Type = network_type,
      Stage = stage,
      Size = NA,
      Edges = NA,
      Components = NA,
      Diameter = NA,
      Transitivity = NA,
      Isolates = NA,
      Degree_Centralization = NA,
      Betweenness_Centralization = NA,
      Closeness_Centralization = NA,
      Cliques_Total = NA,
      Cliques_Max_Size = NA,
      Cliques_Min_Size = NA
    ))
  }
  
  size <- network.size(net)
  edges <- network.edgecount(net)
  
  # Components: Exclude isolates
  components_info <- component.dist(net)
  num_components <- sum(components_info$csize > 1)
  
  isolates_count <- sum(degree(net) == 0)
  
  # Diameter
  dist_matrix <- geodist(net)$gdist
  dist_matrix[is.infinite(dist_matrix)] <- NA
  diameter_val <- max(dist_matrix, na.rm = TRUE)
  
  # Transitivity
  transitivity_val <- gtrans(net)
  
  # Degree Centralization
  deg_vals <- degree(net)
  centralization_deg <- if (length(deg_vals) > 0) {
    (max(deg_vals) * (size - 1) - sum(max(deg_vals) - deg_vals)) / ((size - 1)^2)
  } else {
    NA
  }
  
  # Betweenness Centralization
  btw_vals <- betweenness(net)
  centralization_btw <- if (length(btw_vals) > 0) {
    (max(btw_vals) * (size - 1) - sum(max(btw_vals) - btw_vals)) / ((size - 1)^2)
  } else {
    NA
  }
  
  # Closeness Centralization
  cls_vals <- closeness(net, g = geodist(net)$gdist)
  centralization_cls <- if (length(cls_vals) > 0) {
    (max(cls_vals) * (size - 1) - sum(max(cls_vals) - cls_vals)) / ((size - 1)^2)
  } else {
    NA
  }
  
  # Clique Metrics - Filter cliques of size >= 3
  clique_info <- sna::clique.census(net, mode = "graph", tabulate.by.vertex = FALSE)
  clique_counts <- clique_info$clique.count
  valid_sizes <- which(as.numeric(names(clique_counts)) >= 3 & clique_counts > 0)
  
  total_cliques <- if (length(valid_sizes) > 0) sum(clique_counts[valid_sizes]) else 0
  max_clique_size <- if (length(valid_sizes) > 0) max(valid_sizes) else NA
  min_clique_size <- if (length(valid_sizes) > 0) min(valid_sizes) else NA

  
  # Output Data Frame
  data.frame(
    Network_Type = network_type,
    Stage = stage,
    Size = size,
    Edges = edges,
    Components = num_components,
    Diameter = diameter_val,
    Transitivity = round(transitivity_val, 4),
    Isolates = isolates_count,
    Degree_Centralization = round(centralization_deg, 4),
    Betweenness_Centralization = round(centralization_btw, 4),
    Closeness_Centralization = round(centralization_cls, 4),
    Cliques_Total = total_cliques,
    Cliques_Max_Size = max_clique_size,
    Cliques_Min_Size = min_clique_size
  )
}

```


```{r}
calculate_metrics_statnet <- function(csv_path, network_type, stage) {
  adj_matrix <- as.matrix(read.csv(csv_path, row.names = 1))
  net <- network(adj_matrix, directed = FALSE, matrix.type = "adjacency")
  
  if (network.size(net) <= 1) {
    return(data.frame(
      Network_Type = network_type,
      Stage = stage,
      Size = NA,
      Edges = NA,
      Density = NA,
      Avg_Degree = NA,
      Components = NA,
      Diameter = NA,
      Transitivity = NA,
      Isolates = NA,
      Degree_Centralization = NA,
      Betweenness_Centralization = NA,
      Closeness_Centralization = NA,
      Cliques_Total = NA,
      Cliques_Max_Size = NA,
      Cliques_Min_Size = NA
    ))
  }
  
  size <- network.size(net)
  edges <- network.edgecount(net)
  
  # Density and Average Degree
  density_val <- gden(net)
  avg_degree_val <- mean(degree(net))
  
  # Components: Exclude isolates
  components_info <- component.dist(net)
  num_components <- sum(components_info$csize > 1)
  
  isolates_count <- sum(degree(net) == 0)
  
  # Diameter
  dist_matrix <- geodist(net)$gdist
  dist_matrix[is.infinite(dist_matrix)] <- NA
  diameter_val <- max(dist_matrix, na.rm = TRUE)
  
  # Transitivity
  transitivity_val <- gtrans(net)
  
  # Degree Centralization
  deg_vals <- degree(net)
  centralization_deg <- if (length(deg_vals) > 0) {
    (max(deg_vals) * (size - 1) - sum(max(deg_vals) - deg_vals)) / ((size - 1)^2)
  } else {
    NA
  }
  
  # Betweenness Centralization
  btw_vals <- betweenness(net)
  centralization_btw <- if (length(btw_vals) > 0) {
    (max(btw_vals) * (size - 1) - sum(max(btw_vals) - btw_vals)) / ((size - 1)^2)
  } else {
    NA
  }
  
  # Closeness Centralization
  cls_vals <- closeness(net, g = geodist(net)$gdist)
  centralization_cls <- if (length(cls_vals) > 0) {
    (max(cls_vals) * (size - 1) - sum(max(cls_vals) - cls_vals)) / ((size - 1)^2)
  } else {
    NA
  }
  
  # Clique Metrics - Filter cliques of size >= 3
  clique_info <- sna::clique.census(net, mode = "graph", tabulate.by.vertex = FALSE)
  clique_counts <- clique_info$clique.count
  valid_sizes <- which(as.numeric(names(clique_counts)) >= 3 & clique_counts > 0)
  
  total_cliques <- if (length(valid_sizes) > 0) sum(clique_counts[valid_sizes]) else 0
  max_clique_size <- if (length(valid_sizes) > 0) max(valid_sizes) else NA
  min_clique_size <- if (length(valid_sizes) > 0) min(valid_sizes) else NA

  # Output Data Frame
  data.frame(
    Network_Type = network_type,
    Stage = stage,
    Size = size,
    Edges = edges,
    Density = round(density_val, 4),
    Avg_Degree = round(avg_degree_val, 2),
    Components = num_components,
    Diameter = diameter_val,
    Transitivity = round(transitivity_val, 4),
    Isolates = isolates_count,
    Degree_Centralization = round(centralization_deg, 4),
    Betweenness_Centralization = round(centralization_btw, 4),
    Closeness_Centralization = round(centralization_cls, 4),
    Cliques_Total = total_cliques,
    Cliques_Max_Size = max_clique_size,
    Cliques_Min_Size = min_clique_size
  )
}


```


```{r}
# Define file paths and labels
network_files <- expand.grid(
  type = c("co_retweet", "quote", "reply"),
  stage = 1:6
) %>%
  mutate(
    file_path = paste0("data/adj_matrix_stage", stage, 
                       ifelse(type == "co_retweet", "", paste0("_", type)), ".csv"),
    network_label = case_when(
      type == "co_retweet" ~ "Co-Retweet",
      type == "quote" ~ "Quote Path Co-Retweet",
      type == "reply" ~ "Reply Path Co-Retweet"
    )
  )

# Compute all metrics
all_metrics <- purrr::pmap_dfr(
  list(network_files$file_path, network_files$network_label, network_files$stage),
  calculate_metrics_statnet
)

# Final Table View
print(all_metrics)

# Save Results to CSV
write.csv(all_metrics, "data/network_metrics_summary.csv", row.names = FALSE)

```

| Network_Type           | Stage | Size | Edges | Density | Avg_Degree | Components | Diameter | Transitivity | Isolates |
|------------------------|-------|------|-------|---------|------------|------------|----------|--------------|----------|
| Co-Retweet             | 1     | 112  | 253   | 0.0407  | 9.04       | 1          | 1        | 1.000        | 89       |
| Quote Path Co-Retweet  | 1     | 112  | 0     | 0.0000  | 0.00       | 0          | 0        | 1.000        | 112      |
| Reply Path Co-Retweet  | 1     | 112  | 0     | 0.0000  | 0.00       | 0          | 0        | 1.000        | 112      |
| Co-Retweet             | 2     | 112  | 420   | 0.0676  | 15.00      | 2          | 1        | 1.000        | 71       |
| Quote Path Co-Retweet  | 2     | 112  | 420   | 0.0676  | 15.00      | 2          | 1        | 1.000        | 71       |
| Reply Path Co-Retweet  | 2     | 112  | 420   | 0.0676  | 15.00      | 2          | 1        | 1.000        | 71       |
| Co-Retweet             | 3     | 112  | 28    | 0.0045  | 1.00       | 1          | 1        | 1.000        | 104      |
| Quote Path Co-Retweet  | 3     | 112  | 28    | 0.0045  | 1.00       | 1          | 1        | 1.000        | 104      |
| Reply Path Co-Retweet  | 3     | 112  | 28    | 0.0045  | 1.00       | 1          | 1        | 1.000        | 104      |
| Co-Retweet             | 4     | 112  | 77    | 0.0124  | 2.75       | 4          | 1        | 1.000        | 86       |
| Quote Path Co-Retweet  | 4     | 112  | 57    | 0.0092  | 2.04       | 2          | 1        | 1.000        | 96       |
| Reply Path Co-Retweet  | 4     | 112  | 77    | 0.0124  | 2.75       | 4          | 1        | 1.000        | 86       |
| Co-Retweet             | 5     | 112  | 26    | 0.0042  | 0.93       | 1          | 2        | 0.854        | 103      |
| Quote Path Co-Retweet  | 5     | 112  | 6     | 0.0010  | 0.21       | 1          | 1        | 1.000        | 108      |
| Reply Path Co-Retweet  | 5     | 112  | 21    | 0.0034  | 0.75       | 1          | 1        | 1.000        | 105      |
| Co-Retweet             | 6     | 112  | 10    | 0.0016  | 0.36       | 1          | 1        | 1.000        | 107      |
| Quote Path Co-Retweet  | 6     | 112  | 10    | 0.0016  | 0.36       | 1          | 1        | 1.000        | 107      |
| Reply Path Co-Retweet  | 6     | 112  | 10    | 0.0016  | 0.36       | 1          | 1        | 1.000        | 107      |

**Table 1: Basic Network Structure**

| Network_Type           | Stage | Degree_Centralization | Betweenness_Centralization | Closeness_Centralization |
|------------------------|-------|-----------------------|----------------------------|--------------------------|
| Co-Retweet             | 1     | 0.0786                | 0.0000                     | 0                        |
| Quote Path Co-Retweet  | 1     | 0.0000                | 0.0000                     | 0                        |
| Reply Path Co-Retweet  | 1     | 0.0000                | 0.0000                     | 0                        |
| Co-Retweet             | 2     | 0.1325                | 0.0000                     | 0                        |
| Quote Path Co-Retweet  | 2     | 0.1325                | 0.0000                     | 0                        |
| Reply Path Co-Retweet  | 2     | 0.1325                | 0.0000                     | 0                        |
| Co-Retweet             | 3     | 0.0080                | 0.0000                     | 0                        |
| Quote Path Co-Retweet  | 3     | 0.0080                | 0.0000                     | 0                        |
| Reply Path Co-Retweet  | 3     | 0.0080                | 0.0000                     | 0                        |
| Co-Retweet             | 4     | 0.0237                | 0.0000                     | 0                        |
| Quote Path Co-Retweet  | 4     | 0.0172                | 0.0000                     | 0                        |
| Reply Path Co-Retweet  | 4     | 0.0237                | 0.0000                     | 0                        |
| Co-Retweet             | 5     | 0.0071                | 0.0008                     | 0                        |
| Quote Path Co-Retweet  | 5     | 0.0015                | 0.0000                     | 0                        |
| Reply Path Co-Retweet  | 5     | 0.0058                | 0.0000                     | 0                        |
| Co-Retweet             | 6     | 0.0026                | 0.0000                     | 0                        |
| Quote Path Co-Retweet  | 6     | 0.0026                | 0.0000                     | 0                        |
| Reply Path Co-Retweet  | 6     | 0.0026                | 0.0000                     | 0                        |

**Table 2: Network Centralization**


| Network_Type           | Stage | Cliques_Total | Cliques_Max_Size | Cliques_Min_Size |
|------------------------|-------|----------------|------------------|------------------|
| Co-Retweet             | 1     | 1              | 23               | 23               |
| Quote Path Co-Retweet  | 1     | 0              | NA               | NA               |
| Reply Path Co-Retweet  | 1     | 0              | NA               | NA               |
| Co-Retweet             | 2     | 2              | 25               | 16               |
| Quote Path Co-Retweet  | 2     | 2              | 25               | 16               |
| Reply Path Co-Retweet  | 2     | 2              | 25               | 16               |
| Co-Retweet             | 3     | 1              | 8                | 8                |
| Quote Path Co-Retweet  | 3     | 1              | 8                | 8                |
| Reply Path Co-Retweet  | 3     | 1              | 8                | 8                |
| Co-Retweet             | 4     | 4              | 9                | 5                |
| Quote Path Co-Retweet  | 4     | 2              | 9                | 7                |
| Reply Path Co-Retweet  | 4     | 4              | 9                | 5                |
| Co-Retweet             | 5     | 2              | 7                | 4                |
| Quote Path Co-Retweet  | 5     | 1              | 4                | 4                |
| Reply Path Co-Retweet  | 5     | 1              | 7                | 7                |
| Co-Retweet             | 6     | 1              | 5                | 5                |
| Quote Path Co-Retweet  | 6     | 1              | 5                | 5                |
| Reply Path Co-Retweet  | 6     | 1              | 5                | 5                |

**Table 3: Clique Structural Features**

```{r}

```

```{=html}
<script>
document.addEventListener("DOMContentLoaded", function() {
    const toc = document.getElementById("TOC");
    if (toc) {
        const sourceLink = document.createElement("div");
        sourceLink.innerHTML = `
            <div class="toc-source">
                <a href="https://github.com/troy-yu-cheng/sna-final-paper" 
                   target="_blank" 
                   class="github-button">
                   <svg xmlns="http://www.w3.org/2000/svg" 
                        viewBox="0 0 24 24" 
                        width="16" 
                        height="16" 
                        fill="currentColor"
                        style="vertical-align: middle; margin-right: 5px;">
                     <path d="M12 0C5.373 0 0 5.373 0 12c0 5.303 3.438 9.8 8.207 11.387.6.113.82-.26.82-.577v-2.157c-3.338.726-4.033-1.416-4.033-1.416-.546-1.386-1.332-1.756-1.332-1.756-1.09-.745.083-.73.083-.73 1.205.084 1.84 1.237 1.84 1.237 1.07 1.832 2.807 1.303 3.492.996.108-.774.418-1.303.76-1.602-2.665-.3-5.466-1.332-5.466-5.93 0-1.311.468-2.382 1.237-3.222-.124-.302-.536-1.52.118-3.163 0 0 1.008-.322 3.3 1.23a11.516 11.516 0 0 1 3.002-.403 11.486 11.486 0 0 1 3.002.403c2.292-1.552 3.3-1.23 3.3-1.23.654 1.644.242 2.861.118 3.163.77.84 1.236 1.911 1.236 3.222 0 4.61-2.807 5.627-5.48 5.922.43.372.812 1.103.812 2.222v3.293c0 .321.218.694.825.576C20.565 21.796 24 17.3 24 12 24 5.373 18.627 0 12 0z"/>
                   </svg>
                   View source
                </a>
            </div>
        `;
        toc.appendChild(sourceLink);
    }
});
</script>
```
